---
title: "Codi TFM: Anàlisi ciclable de Barcelona (2017-2020)"
author: "Patricia Andolz Santacana"
date: "22 març - 23 maig 2021"
output:
  html_document:
    toc: true
    theme: cerulean
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval=T, echo=T,comment = NULL)
```

```{css, echo=FALSE}
h1{
  font-size: 30px;
  color:  #000080;
}
h2{
  font-size: 25px;
  color:#4169E1;
}

.author{
  font-size: 25px;
  color:#C71585;
}

.date{
  color:#778899;
}
```

Abans de començar cal instal·lar el connector R-ArcGIS Bridge que permetrà traspassar dades d'R a ArcGIS Pro.
```{r message=FALSE, warning = FALSE}
install.packages("arcgisbinding", repos="https://r.esri.com", type="win.binary")
```

Tot seguit, es carreguen les llibreries necessàries per processar i analitzar dades geoespacials, a més del paquet que permet mostrar de forma més amigable els resultats tabulars.
```{r message=FALSE, warning = FALSE}
library(rgdal)
library(sf)
library(hash)
library(raster)
library(dplyr)
library(stringr)
library(veccompare)
library(sp)
library(ggplot2)
library(scales)
library(units)
library(arcgisbinding)
library(tmap)
library(plyr)
library(zoo)
library(scales)
library(GGally)
library(gganimate)
library(gifski)
library(tm)
library(rmarkdown)

library(kableExtra)
taula<-function(x,rn=F,...){
  kable_styling(kable(x,row.names=rn),...)
}
```

Es defineixen les constants utilitzades al llarg d'aquest estudi: ruta d'accés a les dades i rang temporal del 2017 al 2020 dividit en trimestres.

```{r}
DATA_PATH <- file.path(getwd(), 'Dades')
ARCGIS_PRO_PATH <- 'C:/Users/Patricia/Documents/ArcGIS/Projects/MyProject/MyProject.gdb/'
ARCGIS_PRO_PATH_EXPORT <- 'C:/Users/Patricia/Documents/ArcGIS/Projects/MyProject/Exports/'
AGOL_PATH <- file.path(getwd(), 'AGOL')

YEAR_RANGE <- c(2017:2020)
QUARTER_RANGE <- paste0(c(1:4), 'T')

TEMPORAL_RANGE <- sort(outer(paste0(YEAR_RANGE, '_'), QUARTER_RANGE, FUN="paste0")[1:(length(YEAR_RANGE)*
                                                                                      length(QUARTER_RANGE))])

TEMPORALITY <- hash(QUARTER_RANGE, c('0330', '0630', '0930', '1230'))

TEMPORALITY_QUARTER <- hash(c('0330', '0630', '0930', '1230'), QUARTER_RANGE)
```

Es defineixen les funcions bàsiques i comuns a les quatre temàtiques d'estudi per carregar i tractar els fitxers i generar el conjunt de dades.

En concret, si els fitxers a carregar es troben comprimits en un ZIP, cal extreure el seu contingut per cercar el fitxer *Shapefile* a importar a R (funció `ZIP_extract_files`). Per altra banda, la funció `load_data` s'encarrega de retornar el conjunt de dades carregades.

```{r}
#funció per descomprimir un fitxer ZIP. Paràmetres d'entrada:
#   * directori
#   * nom del fitxer ZIP
#   * extensió del fitxer a extreure del ZIP (per defecte s'extreuen tots els fitxers)
#   * booleà per reanomenar els fitxers (per defecte es sobreescriu el nom pel del fitxer zip)
ZIP_extract_files = function(path, fileName, fileExtension='', changeName=TRUE){
  
  #nom absolut del fitxer a descomprimir
  file <- paste0(path, '/', fileName, '.zip')
  
  #definir el tipus de fitxer a cercar dins del ZIP
  search <- paste0(fileExtension, '$')
  
  #cercar els fitxers dins del ZIP que compleixen la condició 
  zipped_names <- grep(search, unzip(file, list=TRUE)$Name, ignore.case=TRUE, value=TRUE)
  
  #extreure els fitxers localitzats en el ZIP
  unzip(file, files=zipped_names, exdir=path)
  
  if (changeName){
      #sobreescruiure del nom dels fitxers interns del ZIP 
      #(serveix per evitar que els fitxers segueixin la nomenclatura estàndard i no es sobreescriguin)
      nameFrom <- NULL
      nameTo <- NULL
      for(e in zipped_names){
        nameFrom <- c(nameFrom, paste0(path, '/', e))
        nameTo <- c(nameTo, paste0(path, '/', fileName,'.', unlist(strsplit(e, "[.]"))[2]))
      }
      file.rename(from=nameFrom, to=nameTo)
  }
}


#funció per carregar dades. Paràmetres d'entrada:
#   * directori
#   * nom del fitxer
#   * extensió del fitxer a tractar
#   * codificació del fitxer (per defecte el de Windows)
#   * separador de les dades (per defecte la coma)
#   * booleà per reanomenar els fitxers (per defecte se'ls hi modifica el nom)
load_data = function(path, fileName, fileExt, optEnc='ENCODING=WINDOWS-1252', separador=',', rename=TRUE){

  #si l'extensió del fitxer és un ZIP, extreure el/s fitxer/s SHP a carregar
  if (grepl("zip", fileExt, ignore.case = T)){
    ZIP_extract_files(path, fileName, changeName=rename)
    fileExt <- 'shp'
  }
  
  #nom absolut del fitxer a carregar
  file <- paste0(path, '/', fileName, '.', fileExt)

  #carregar les dades, diferenciant la forma d'importar-les en funció del tipus de fitxer
  data <- NULL
  if (grepl("shp", fileExt, ignore.case = T)){
    data <- st_read(dsn=file, options=optEnc, quiet=TRUE) 
  }else if(grepl("csv", fileExt, ignore.case = T)){
    data <- read.csv(file, header=TRUE, sep=separador, fileEncoding = "UTF-8")
  }
  return (data)
}
```

Durant tot l'estudi s'ha de treballar amb les dades espacials en el format establert pel [Reial Decret 1071/2007](https://www.mapa.gob.es/es/cartografia-y-sig/ide/directorio_datos_servicios/caracteristicas_wms.aspx), on es regula el sistema geodèsic en el qual s'ha de compilar la informació cartogràfica oficial a Espanya. En concret, el [sistema de referència estipulat](https://spatialreference.org/ref/epsg/25831/) és el **ETRS89 (EPSG:25831)**.

```{r}
#ETRS89 (EPSG:25831)
crs_legal <- st_crs(25831)
```

Finalment, s'estableix la connexió entre R i ArcGIS PRO mitjançant el connector R-ArcGIS Bridge i la sessió d'usuari de *Learning* creat prèviament.

```{r}
arc.check_product()
arc.check_portal()
```



# 1. Infraestructura ciclable

## 1.1. Càrrega de les dades

Es defineix el directori pare que conté les dades referents a la infraestructura ciclable, i es defineixen els tipus de vies a tractar.
De cada tipus de via es carreguen totes les dades des del 2017 al 2020 separades per trimestres i s'uneixen totes les dades de la infraestructura en un únic objecte de tipus `simple feature` (SF). Aquest objecte està format per un conjunt d'atributs, entre les quals es disposa de les característiques geomètriques de cada registre.

Durant la càrrega de cada fitxer, s'afegeixen certes dades que permeten identificar el tipus de via que s'ha carregat, així com la temporalitat de les dades importades (any, trimestre i data final del trimestre), ja que els fitxers originals no disposen de camps específics amb aquesta diferenciació.

```{r message=FALSE}
DATA_PATH_INFRAESTR <- file.path(DATA_PATH, 'T1.infraestructura_ciclable')
INFRAESTR_TYPE <- c("carril_bici", "vies_ciclables", "ronda_verda", "zones30_poligons", 
                    "corredors_bici", "carril_bici_cons", "carrers_pacificats")

#conjunt amb totes les dades de la infraestructura
sfInfraestr <- NULL

#per cada tipus de via i per cada trimestre
for (i in INFRAESTR_TYPE){
  for (t in TEMPORAL_RANGE){
    #construir el nom del fitxer a carregar a partir del tipus d'infraestructura i del fitxer temporal
    fileName <- paste0(t, '_', i)
    path <- paste0(DATA_PATH_INFRAESTR, '/', i)
    
    #comprovar si el fitxer existeix en el directori
    if(file.exists(paste0(path, '/', fileName, '.zip'))){
      #carregar les dades del fitxer
      d <- load_data(path, fileName, 'zip')
    
      #crear les variables de tipus de via i de temporalitat de les dades
      d$type <- gsub("_", " ", i)
      time <- unlist(strsplit(t, "_"))
      d$year <- as.numeric(time[1])
      d$quarter <- time[2]
      d$temporality <- paste0(time[1], TEMPORALITY[[time[2]]])
      
      #validar que estigui tot en el mateix sistema de referència. Si no ho està, transformar-ho al crs legal
      if(st_crs(d) != crs_legal){
        st_transform(d, crs=crs_legal)
        print("S'han transformat les dades geogràfiques al nou sistema de referència (EPSG:25831)!!")
      }
      
      #afegir el nou conjunt de dades al conjunt existent
      sfInfraestr <- bind_rows(sfInfraestr, d)
    }
  }
}
```

Es valida el format del *dataset* d'infraestructures (`sfInfraestr`) construït. Es pot veure que està en el format estàndard per representar geometries espacials dels objectes i que en total s'han carregat 21.816 trams ciclables dels quals es disposa de 13 atributs.

```{r}
cat("El conjunt de dades està en format", paste(unlist(class(sfInfraestr)), collapse=' i '), 
    "i utilitza el CRS:\n", paste(unlist(st_crs(sfInfraestr)), collapse=' '))
```

```{r}
str(sfInfraestr)
```

```{r}
taula(head(as.data.frame(sfInfraestr), 3))
```



## 1.2. Neteja i tractament de dades

Analitzant el tipus de dades que s'ha assignat durant la càrrega es pot veure que les variables qualitatives nominals s'han tractat com a cadenes de caràcters en comptes de factors, pel que s'aplica la conversió a `factor` per poder realitzar càlculs de freqüència d'aparició de cada nivell.

```{r}
var.qualitativa <- names(sfInfraestr)[sapply(sfInfraestr, function(x) (is.character(x)))]

df <- as.data.frame(sfInfraestr)
for (v in var.qualitativa){
  sfInfraestr[,v] <- as.factor(df[,v])
}

str(sfInfraestr)
```

A continuació, es du a terme una anàlisi descriptiva numèrica de les dades, calculant la freqüència dels nivells de les variables qualitatives i resums de la distribució en quartils de les quantitatives.

```{r}
summary(as.data.frame(sfInfraestr)[, c(names(sfInfraestr)[1:5], 'year', 'any', 'quarter', 
                                       'trimestre', 'temporality', 'X_timestamp')])
```

Es pot veure que el `CODI_CAPA` identifica el tipus de via ciclable, pel que seria equivalent al camp `type` creat durant la càrrega dels fitxers. Per tant, es descarta el valor numèric per no aportar informació rellevant.

Tots els registres prenen el mateix valor a `CODI_SUBCAPA`, pel que es pot menysprear per presentar variància nul·la.

La variable `ID` es tracta d'un identificador únic, que pels polígons coincideix al llarg dels anys, però que pels trams ciclables cada trimestre pren un valor diferent pel mateix carrer, com es pot veure amb el següent carril bici (*Carril Bici Moll de la Barceloneta*). Així doncs, es pot ometre aquesta variable de l'estudi.

```{r}
cat('En total hi ha', length(unique(sfInfraestr$ID)), 'identificadors únics (ID), mentre que hi ha', 
    length(unique(sfInfraestr$TOOLTIP)), 'noms de trams únics (TOOLTIP)')
```

```{r}
taula(head(as.data.frame(sfInfraestr[sfInfraestr$TOOLTIP=='Carril Bici Moll de la Barceloneta', ])
           [,names(sfInfraestr) %in% c('ID', 'CODI_CAPA', 'CODI_SUBCA', 'TOOLTIP', 'type', 'year', 'quarter')]))
```

Pel que fa a la temporalitat, el 40,57% de registres presenten valors absents en els atributs de `mes`, `any`, `trimestre` i `X_timestamp`. Es pot comprovar que es tracten de camps nous que s'han incorporat en els fitxers dels últims dos anys (a partir del 2019).

```{r}
cat('El', round((sum(is.na(sfInfraestr$X_timestamp))/nrow(sfInfraestr))*100,2), 
    '% dels registres temporals estan a nulls')
```

```{r}
sfInfraestrWithTimest <- as.data.frame(sfInfraestr[!is.na(sfInfraestr$X_timestamp),])
sfInWithTimest.df <- sfInfraestrWithTimest %>% dplyr::count(X_timestamp, temporality, mes, quarter, any)
taula(sfInWithTimest.df)
```

Per altra banda, es pot veure que la temporalitat que ha enregistrat l'Ajuntament de Barcelona (`X_timestamp`) pràcticament coincideix amb la que s'ha assignat durant la càrrega de les dades (`temporality`), doncs el `X_timestamp` conté la data d'inici del següent trimestre, mentre que el `temporality` marca la data de tancament del trimestre que conté les dades.

Comentar que en el cas del tercer trimestre del 2020, la temporalitat no coincideix en tots els registres, doncs en uns casos es fa referència a l'inici del mes com en els anys anteriors (tancament del tercer trimestre), mentre que en altres, s'ha definit la data del trimestre a finals de mes (28/10/2020). Aquests últims registres coincideixen amb les dades dels fitxers dels carrers pacificats i dels corredors bici, els quals es corresponen a noves zones de convivència derivades de la COVID-19.

A més, en el cas del quart trimestre del 2020, l'enregistrament s'ha realitzat molt a posterior del tancament del trimestre (gairebé a mitjans de febrer).

```{r}
sfInfraestr_20210210 <- as.data.frame(sfInfraestrWithTimest[sfInfraestrWithTimest$X_timestamp=='20201028',])
sfInWithT_20210210 <- sfInfraestr_20210210 %>% dplyr::count(X_timestamp, temporality, quarter, type)
taula(sfInWithT_20210210)
```

Així doncs, per l'estudi s'utilitzaran els camps temporals creats durant la càrrega `year`, `quarter` i `temporality`.
Per aquest motiu, es procedeix a eliminar les variables següents i a reanomenar `TOOLTIP` per `name`.

```{r}
drop <- c('ID', 'CODI_CAPA', 'CODI_SUBCA', 'X_timestamp', 'any', 'mes', 'trimestre')
sfInfraestr <- sfInfraestr[,!names(sfInfraestr) %in% drop]
colnames(sfInfraestr)[1] <- "name"
taula(head(as.data.frame(sfInfraestr),3))
```

A continuació, es cerquen les variables que presenten valors nuls. En aquest cas, s'observen 1.216 registres sense nom assignat (`name`), els quals es corresponen a les 76 zones de 30 que, durant els 16 trimestres d'estudi, no se'ls hi ha donat un nom als polígons.

```{r}
NAs.num <- sapply(sfInfraestr, function(k)sum(is.na(k)))
print(NAs.num[NAs.num!=0])
```

```{r}
taula(head(as.data.frame(sfInfraestr[is.na(sfInfraestr$name),]) %>% dplyr::count(type)),full_width=F)
```

Aquests `NA` són tractats assignant-els-hi el nom *zona a 30* perquè en la visualització no es mostri el camp buit.

```{r}
taula(head(as.data.frame(sfInfraestr[is.na(sfInfraestr$name),]),3))
```

Així doncs, s'assigna el literal als registres que contenen el nom del tram absent i es valida que no quedin variables amb valors sense informar.

```{r}
if(NAs.num[1]!=0){
  sfInfraestr$name <- as.character(sfInfraestr$name)
  sfInfraestr[is.na(sfInfraestr$name),]$name <- 'zona a 30'
  sfInfraestr$name <- as.factor(sfInfraestr$name)
}

NAs.num <- sapply(sfInfraestr, function(k)sum(is.na(k)))
if(length(NAs.num[NAs.num!=0])==0){
  cat('No hi ha valors absents!')
}else{
  cat(NAs.num[NAs.num!=0])
}
```



## 1.3. Anàlisi de dades

Tot seguit, s'analitza numèricament l'evolució de la infraestructura ciclable amb R. Així doncs, es defineixen els colors que diferenciaran cada tipus de via, així com una funció on donat un conjunt de dades, mostra per pantalla la gràfica amb l'evolució de la infraestructura ciclable, comptant el nombre de trams que hi ha de cada tipus de via, i retorna les estadístiques numèriques.

```{r}
COLORS <- c("carrers pacificats"="#FFAA00", "carril bici"="#38A800", "carril bici cons"="#E60000", 
            "corredors bici"="#005CE6", "ronda verda"="#00A884", "vies ciclables"="#DF73FF", 
            "zones30 poligons"="#FFBEE8")

#funció per mostrar gràficament l'evolució del nombre de trams de cada tipus de via. Paràmetres d'entrada:
#   * conjunt de dades de trams amb component temporal
plotEvolSectionNumPerType = function(data){
  #convertir el SF en un DF per aplicar transformacions sobre els atributs
  df <- as.data.frame(data)
  
  #definir les dades temporals en format YYYYMMDD
  df$temporality <- as.Date(as.character(df$temporality), "%Y%m%d")

  #comptar el nombre de seccions (registres) de cada tipus de via i moment temporal
  dfStats <- df %>% dplyr::count(type, temporality)
  
  #mostrar les estadístiques calculades
  p <- ggplot(dfStats, aes(x=temporality, y=n)) + 
       geom_line(aes(color=type), size = 1) + scale_colour_manual(values = COLORS) + 
       ggtitle("Evolution of Cyclable Infraestructure")+ xlab("Temporality") + ylab("Number of sections")
  
  plot(p)
  
  return (dfStats)
}
```

Es pot observar que a partir del segon trimestre del 2020 es dispara el nombre de vies ciclables habilitades. Això es deu al fet que per facilitar la mobilitat ciutadana, aplicant les mesures de prevenció de la COVID-19, es va promoure l'ús de la bicicleta, i la forma més ràpida d'incorporar vies per la seva circulació, era establint espais de convivència (zones de 10, 20 i 30).

```{r}
dfStatsNumSections <- plotEvolSectionNumPerType(sfInfraestr)
```

Obviant aquestes vies de convivència es pot veure que la ronda verda des del 2017 conté el mateix nombre de trams, així com s'han mantingut durant aquests anys les zones definides a 30.

Per altra banda, s'aprecia una tendència a incrementar el nombre de trams amb carrils bici, encara que destaca que la planificació de la construcció de nous carrils és menor cada trimestre, disminuint en picat a partir del 2018.

Per altra banda, es pot apreciar que els corredors bici i els carrers pacificats s'han instaurat també com a mesura anti-COVID, doncs apareixen a partir del tercer trimestre del 2020.

```{r}
vies <- c('vies ciclables')
dfStatsNumSections2 <- plotEvolSectionNumPerType(sfInfraestr[!(sfInfraestr$type %in% vies),])
```

A continuació, es defineix una funció genèrica on donat un conjunt de dades, un atribut per agrupar les dades i un valor temporal de filtre, calcula la diferència (increment o decrement) que ha patit el camp `num` del conjunt de dades d'entrada comparant el primer registre de cada grup amb l'últim registre de cada grup.

```{r}
#funció per calcular l'increment d'una variable al llarg del temps. Paràmetres d'entrada:
#   * conjunt amb la variable d'estudi
#   * variable agregadora de dades
#   * temporalitat màxima a considerar l'increment
calcDifferenceByTemporality = function(dfStats, group, valueFilter){
  
  #calcular, per cada agrupació, la diferència (en percentatge) de valors entre el primer registre i l'últim
  dif <- dfStats %>%
          group_by(dfStats[,group]) %>%
          dplyr::mutate(delta = ((n[temporality==valueFilter] - n)*100)/n)
  diffPerType <- dif[!duplicated(dif[,group]),]
  
  #mostrar l'agrupació junt amb el seu percentatge diferencial de forma descendent 
  diffPerType <- diffPerType[order(diffPerType$delta, decreasing=TRUE), c(paste0(group), 'delta')]
  diffPerType$delta <- paste(round(diffPerType$delta, 2), "%", sep="")
  
  taula(diffPerType, full_width=F)
}
```

Així doncs, mitjançant la següent funció es pot calcular la diferència (increment o decrement) que ha patit cada tipus de via des del primer valor conegut fins a l'últim (2020-12-30) respecte al nombre de trams que la formen. D'aquesta forma, numèricament es pot comprovar la diferència comentada en les gràfiques anteriors.

```{r}
calcDifferenceByTemporality(dfStatsNumSections, 'type', '2020-12-30')
```

Per altra banda, s'analitza el quilometratge ciclable per veure com es va ampliant la xarxa viària habilitada per bicis.

Així doncs, s'utilitza la funció `st_lenght` per calcular la llargada d'un tram en quilòmetres, i `st_area` per obtenir la superfície d'un polígon en quilòmetres quadrats.

```{r}
sfInfraestr$length <- st_length(sfInfraestr)
sfInfraestr$area <- st_area(sfInfraestr)

taula(head(as.data.frame(sfInfraestr)[, !names(sfInfraestr) %in% c('temporality', 'geometry')]))
```

A continuació, es defineix una funció on donat un conjunt de dades, mostra per pantalla la gràfica amb l'evolució temporal dels quilòmetres lineals de cada tipus de via, i retorna les estadístiques numèriques.

```{r}
#funció per mostrar gràficament l'evolució del quilometratge dels trams de cada tipus de via. Paràmetres d'entrada:
#   * conjunt de dades de trams amb component temporal
plotEvolKmPerType = function(data){
  #convertir el SF en un DF per aplicar transformacions sobre els atributs
  df <- as.data.frame(data)
  
  #calcular per cada tram la llarga en km
  df$length <- as.double(set_units(df$length, km))
  
  #definir les dades temporals en format YYYYMMDD
  df$temporality <- as.Date(as.character(df$temporality), "%Y%m%d")
  
  #sumar els km dels trams de cada tipus de via i moment temporal
  dfStats <- aggregate(df$length, by=list(type=df$type, temporality=df$temporality), FUN=sum)
  colnames(dfStats)[3] <- "n"
  
  #mostrar les estadístiques calculades
  p <- ggplot(dfStats, aes(x=temporality, y=n)) + 
       geom_line(aes(color=type), size = 1) + scale_colour_manual(values = COLORS) +
       ggtitle("Evolution of Cyclable Infraestructure")+ xlab("Temporality") + ylab("Longitude [km]")
  plot(p)
  
  return (dfStats)
}
```

```{r}
dfStatsKmType <- plotEvolKmPerType(sfInfraestr[sfInfraestr$type!='zones30 poligons',])
```

Anàlogament, s'aprecia la mateixa evolució pel que fa al quilometratge de les vies ciclables.

```{r}
calcDifferenceByTemporality(dfStatsKmType, 'type', '2020-12-30')
```

Altrament, es defineix una funció equivalent a l'anterior, però que té en compte els quilòmetres quadrats (àrea) dels diferents tipus de via, en aquest cas aplicable sobre les zones a 30.

```{r}
#funció per mostrar gràficament l'evolució de l'àrea d'una secció. Paràmetres d'entrada:
#   * conjunt de dades de seccions amb component temporal
plotEvolKm2PerType = function(data){
  #convertir el SF en un DF per aplicar transformacions sobre els atributs
  df <- as.data.frame(data)
  
  #calcular per cada secció la seva àrea en km2
  df$area <- as.double(set_units(df$area, km^2))
  
  #definir les dades temporals en format YYYYMMDD
  df$temporality <- as.Date(as.character(df$temporality), "%Y%m%d")
  
  #sumar els km2 de les seccions de cada tipus de via i moment temporal
  dfStats <- aggregate(df$area, by=list(type=df$type, temporality=df$temporality), FUN=sum)
  colnames(dfStats)[3] <- "n"
  
  #mostrar les estadístiques calculades
  p <- ggplot(dfStats, aes(x=temporality, y=n)) + 
       geom_line(aes(color=type), size = 1) + scale_colour_manual(values = COLORS) +
       ggtitle("Evolution of Cyclable Infraestructure")+ xlab("Temporality") + ylab("Area [km^2]")
  plot(p)
  
  return (dfStats)
}
```

D'aquesta forma, s'analitza la superfície dels polígons amb limitació de velocitat a 30 km/h, que com es pot veure és constant en el temps amb menys de $18,9{\ }km^{2}$.

```{r}
dfStatsKm2Type <- plotEvolKm2PerType(sfInfraestr[sfInfraestr$type=='zones30 poligons',])
```

```{r}
calcDifferenceByTemporality(dfStatsKm2Type, 'type', '2020-12-30')
```

Finalment, es traslladen aquestes dades al producte d'ArcGIS Pro mitjançant el connector R-ArcGIS Bridge.

En concret, es donen d'alta a la BBDD del projecte d'ArcGIS les dades en dos fitxers diferenciant els trams lineals de les zones poligonals, doncs si no, ArcGIS Pro no reconeix correctament els polígons si es realitza la càrrega de forma conjunta.

Comentar que per poder reprocessar el script d'R, és necessari eliminar la capa i sobreescriure-la (el `overwrite` no sempre és suficient). Aquests passos s'han de realitzar amb l'aplicatiu d'ArcGIS Pro aturat, en cas contrari, no es realitza l'eliminació del contingut de la capa.

```{r}
arc.delete(paste0(ARCGIS_PRO_PATH, 'carrers'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'carrers'), data=sfInfraestr[sfInfraestr$type!='zones30 poligons',], 
          validate=TRUE, overwrite=TRUE)

arc.delete(paste0(ARCGIS_PRO_PATH, 'zones'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'zones'), data=sfInfraestr[sfInfraestr$type=='zones30 poligons',], 
          validate=TRUE, overwrite=TRUE)
```



# 2. Ús de bicicleta

## 2.1. Càrrega de les dades

Com en la temàtica anterior, es defineix el directori pare que conté les dades d'aforament dels diversos tipus de vies de Barcelona. Aquesta informació està dividida en dos fitxers, per una banda, es disposa a nivell anual de la descripció dels punts de mesura disponibles, i per altra banda, dels valors enregistrats per cadascun d'aquests dispositius al llarg de l'any. 

En aquest cas, és necessari generar 2 fitxers diferents, un amb el detall de les mesures que ha pres cada dia cada equip, i un altre amb un resum general dels equips que inclogui la mitjana d'IMD enregistrat per equip anualment. Per això, és millor netejar els dos fitxers per separat abans de fer els dos tipus d'unió.

Així doncs, es comença carregant totes les dades dels equips de mesura dels quatre anys d'estudi (2017-2020) en un objecte de tipus `simple feature` (SF), doncs aquests punts contenen les coordenades en format WGS84 i ETRS89 de la seva ubicació.

Durant la càrrega del fitxer dels equips, s'afegeix el camp `year` per poder identificar el moment temporal de l'equip de mesura. Comentar que és necessari transformar el codi d'aforament (`Id_aforament`) a caràcter perquè a partir del 2018, els codis contenen valors alfanumèrics.

Destacar que s'han utilitzat les coordenades de `longitud` i `latitud` pel càlcul de la geometria, les quals es troben en el format WGS84, i que per tant, ha sigut necessari aplicar la transformació al sistema de referència legal.

```{r message=FALSE}
DATA_PATH_US <- file.path(DATA_PATH, 'T2.aforament')

#conjunt amb totes les dades dels accidents
sfEquipsAforament <- NULL

#per cada any
for (t in YEAR_RANGE){
  
  #construir el nom i el path del fitxer a carregar tenint en compte l'any de les dades
  fileName <- paste0(t, '_aforament_descripcio')
  path <- paste0(DATA_PATH_US, '/', 'descripcio')

  #comprovar si el fitxer existeix en el directori
  if(file.exists(paste0(path, '/', fileName, '.csv'))){
    #carregar les dades del fitxer
    d <- load_data(path, fileName, 'csv')
    d$Id_aforament <- as.character(d$Id_aforament)
    d$year <- as.numeric(t)

    #Els valors de Longitud/Latitud s'acostumen a donar en format en WGS 84 --> EPSG: 4326
    # (https://www.nceas.ucsb.edu/sites/default/files/2020-04/OverviewCoordinateReferenceSystems.pdf)
    sfD <- st_as_sf(d, coords=c('Longitud', 'Latitud'), crs=st_crs(4326))
    #transformar al crs legal
    sfD <- st_transform(sfD, crs=crs_legal)
    
    #afegir el nou conjunt de dades al conjunt existent
    sfEquipsAforament <- bind_rows(sfEquipsAforament, sfD)
  }
}

str(sfEquipsAforament)
```

Tot seguit, es carrega el detall de les mesures presses durant els quatre anys i es valida el format del conjunt creat.

```{r}
#conjunt amb totes les dades de mesures (valor IMD)
dfMesures <- NULL

#per cada any
for (t in YEAR_RANGE){
  
  #construir el nom i el path del fitxer a carregar tenint en compte l'any de les dades
  fileName <- paste0(t, '_aforament_detall_valor')
  path <- paste0(DATA_PATH_US, '/', 'detall')

  #comprovar si el fitxer existeix en el directori
  if(file.exists(paste0(path, '/', fileName, '.csv'))){
    #carregar les dades del fitxer
    d <- load_data(path, fileName, 'csv')
    d$Id_aforament <- as.character(d$Id_aforament)

    #afegir el nou conjunt de dades al conjunt existent
    dfMesures <- bind_rows(dfMesures, d)
  }
}

str(dfMesures)
```



## 2.2. Neteja i tractament de dades

En primer lloc, s'eliminen del fitxer `sfEquipsAforament` els camps irrellevants per evitar treballar amb un *dataset* d'alta dimensionalitat quan es realitzi la unió amb les dades del detall d'IMD.

En concret, per l'estudi no interessa el detall tècnic de l'equip que ha realitzat el mesurament, així com les característiques del nombre de vies, a més, no és necessari disposar de les coordenades en format ETRS89 (ja es disposa de l'atribut `geometry` amb el detall del punt), i el `Codi_tipus_aforament` es tracta de la codificació numèrica del `Desc_tipus_aforament`, pel que és redundant.

```{r}
drop <- c('Codi_tipus_equip_mesura', 'Desc_tipus_equip_mesura', 'Num_carrils', 
          'X_ETRS89', 'Y_ETRS89', 'Codi_tipus_aforament')
sfEquipsAforament <- sfEquipsAforament[,!names(sfEquipsAforament) %in% drop]
cat("Variables rellevants:", vector.print.with.and(names(sfEquipsAforament)))
```

A continuació, es converteixen les variables qualitatives nominals, detectades com a caràcters durant la càrrega, en factors.

```{r}
var.qualitativa <- names(sfEquipsAforament)[sapply(sfEquipsAforament, function(x) (is.character(x)))]

df <- as.data.frame(sfEquipsAforament)
for (v in var.qualitativa){
  sfEquipsAforament[,v] <- as.factor(df[,v])
}

str(sfEquipsAforament)
```

Tot seguit, es realitzen unes estadístiques bàsiques per conèixer el contingut.

```{r}
summary(as.data.frame(sfEquipsAforament)[, !names(sfEquipsAforament) %in% "geometry"])
```

Es pot veure que la variable `Desc_tipus_aforament` al llarg dels anys ha canviat la forma de codificació dels literals, pel que es transformen tots els valors a minúscules.

```{r}
sfEquipsAforament$Desc_tipus_aforament <- tolower(sfEquipsAforament$Desc_tipus_aforament)
sfEquipsAforament$Desc_tipus_aforament <- droplevels(as.factor(as.data.frame(sfEquipsAforament)$Desc_tipus_aforament))

summary(as.data.frame(sfEquipsAforament)[, c("Desc_tipus_aforament")]) 
```

Tot seguit, es converteixen les variables `Codi_districte` i `Codi_barri` a factors en tractar-se de dades qualitatives.

```{r}
sfEquipsAforament$Codi_districte <- as.factor(sfEquipsAforament$Codi_districte)
sfEquipsAforament$Codi_barri <- as.factor(sfEquipsAforament$Codi_barri)
summary(as.data.frame(sfEquipsAforament)[, c("Codi_districte", "Codi_barri")])
```

Es comprova si hi ha registres amb valors absents i s'identifiquen 2 registres que no disposen de codi de districte ni barri associat, tot i que sí que tenen un punt geomètric vàlid.

```{r}
NAs.num <- sapply(sfEquipsAforament, function(k)sum(is.na(k)))
print(NAs.num[NAs.num!=0])
```

```{r}
taula(sfEquipsAforament[is.na(sfEquipsAforament$Codi_districte) | is.na(sfEquipsAforament$Codi_barri),])
```

Per aquest motiu, es carreguen les dades administratives de Barcelona pel que fa al municipi, districtes i barris, per poder ubicar aquests punts dins d'un barri i, en conseqüència, dins d'un districte a partir de la seva referència geogràfica.

Per això, es defineix la funció `loadPoligons`, on donat un fitxer, es carrega amb la funció `load_data` i es valida el seu sistema de referència. Aquesta funció és utilitzada per incorporar els límits administratius.

```{r}
#funció per carregar dades administratives. Paràmetres d'entrada:
#   * directori
#   * nom del fitxer
#   * extensió del fitxer
#   * codificació del fitxer (per defecte Windows)
loadPoligons = function(path, filename, extension, optEnc='ENCODING=WINDOWS-1252'){
  #carregar les dades administratives
  a <- load_data(path, filename, extension, optEnc)
  
  #validar que estigui tot en el mateix sistema de referència. Si no ho està, transformar-ho al crs legal
  if(st_crs(a) != crs_legal){
    st_transform(barris, crs=crs_legal)
    print("S'han transformat les dades geogràfiques al nou sistema de referència (EPSG:25831)!!")
  }
  
  return (a)
}
```

```{r message=FALSE, warning = FALSE, fig.height=5}
DATA_PATH_LIM <- file.path(DATA_PATH, 'BCN_UNITATS_ADM')

barris <- loadPoligons(DATA_PATH_LIM, 'Barris_UNITATS_ADM', 'zip', optEnc='UTF-8')
districtes <- loadPoligons(DATA_PATH_LIM, 'Districtes_UNITATS_ADM', 'zip', optEnc='UTF-8')
municipi <- loadPoligons(DATA_PATH_LIM, 'TermeMunicipal_UNITATS_ADM', 'zip')

b <- qtm(barris, title='Barris')
d <- qtm(districtes, title='Districtes')
m <- qtm(municipi, title='Municipi')

tmap_arrange(b,d,m)
```

Així doncs, es defineix una funció reutilitzable pels futurs estudis de les temàtiques restants on, donat un conjunt de dades, els índexs de les files dels registres que es volen ubicar en el municipi informat, retorna per defecte la informació del codi del districte i del barri on es troba, així com el detall del nom d'aquests. A més, permet indicar si no es vol recuperar tota la informació i només es vol obtenir els codis.

```{r}
#funció per obtenir les dades administratives (districte i barri) d'uns registres. Paràmetres d'entrada:
#   * conjunt de dades
#   * registres a ubicar
#   * municipi al qual pertanyen
#   * booleà per retornar també el nom del barri i districte (per defecte es retorna tota la informació)
locateItems = function(data, inUnknown, municipi, allInfo=TRUE){
  
  #validar si es disposa dels límits de districtes i barris del municipi
  #en cas negatiu, carregar els polígons
  if(is.null(districtes)){
    districtes <- loadPoligons(DATA_PATH_LIM, 'Districtes_UNITATS_ADM', 'zip', optEnc='UTF-8')
  }
  
  if (is.null(barris)){
    barris <- loadPoligons(DATA_PATH_LIM, 'Barris_UNITATS_ADM', 'zip', optEnc='UTF-8')
  }
  
  codeDist <- NULL
  codeBar <- NULL
  nameDist <- NULL
  nameBar <- NULL
  
  #per cada registre que es vulgui calcular la seva ubicació (districte i barri)
  for (row in inUnknown){
    #validar que la referència geogràfica (coordenades) del registre es trobin dins del municipi
    if(st_within(data[row,], municipi, sparse=FALSE)){

      #localitzar el barri en el qual es troba, i en conseqüència el districte
      locateAt <- st_within(data[row,], barris, sparse=FALSE)
      
      codeDist <- append(codeDist,as.numeric(barris[which(locateAt),]$DISTRICTE))
      codeBar <- append(codeBar, as.numeric(barris[which(locateAt),]$BARRI))
      
      #si es sol·licita tota la informació, incloure les dades del nom del districte i barri
      if (allInfo){
        nameDist <- append(nameDist, districtes[as.numeric(districtes$DISTRICTE)==tail(codeDist, n=1),]$NOM)
        nameBar <- append(nameBar, barris[which(locateAt),]$NOM)
      }
      
    #si el registre no es troba dins del municipi, les dades retornades contenen un -1
    }else{
      codeDist <- append(codeDist, -1)
      codeBar <- append(codeBar, -1)
      if (allInfo){
        nameDist <- append(nameDist, '-1')
        nameBar <- append(nameBar, '-1')
      }
    }
  }
  
  #retornar els codis i noms administratius
  infoLocated <- list('codeDist'=codeDist, 'codeBar'=codeBar, 'nameDist'=nameDist, 'nameBar'=nameBar)
    
  return (infoLocated)
}
```

En aquest cas, es localitzen els equips sense dades administratives i s'utilitza la funció `locateItems` per obtenir la informació dels codis, els quals seran informats en els registres del conjunt de dades.

```{r}
#es cerquen els índexs dels aparells de mesura que no tenen informat les dades administratives de barri i/o districte
indDesconeguts <- which(is.na(sfEquipsAforament$Codi_districte) | is.na(sfEquipsAforament$Codi_barri))

info <- locateItems(sfEquipsAforament, indDesconeguts, municipi, allInfo=FALSE)

sfEquipsAforament[indDesconeguts,]$Codi_districte <- info$codeDist
sfEquipsAforament[indDesconeguts,]$Codi_barri <- info$codeBar

taula(sfEquipsAforament[indDesconeguts,])
```

```{r}
NAs.num <- sapply(sfEquipsAforament, function(k)sum(is.na(k)))
if(length(NAs.num[NAs.num!=0])==0){
  cat('No hi ha valors absents!')
}else{
  cat(NAs.num[NAs.num!=0])
}
```

Per altra banda, hi ha 194 registres que contenen el valor 0 en els codis de districte i barri, dels quals 192 es corresponen a aparells de mesura d'aforament de les rondes i  2 a les bicis. 

```{r}
tmp_DistrBarri_0 <- as.data.frame(sfEquipsAforament[sfEquipsAforament$Codi_districte==0 | 
                                                      sfEquipsAforament$Codi_barri==0,])
tmp_DistrBarri_0 <- tmp_DistrBarri_0 %>% dplyr::count(Desc_tipus_aforament)
taula(tmp_DistrBarri_0, full_width=F)
```

En el cas de les rondes, serveix per no desvirtuar l'aforament del barri/districte, pel que no es realitza cap tractament especial. Però els equips de bicis s'han de reubicar en el districte corresponent.

```{r}
#cercar els índexs dels aparells de mesura de bici que no tenen informades les dades administratives
indDesconeguts <- which((sfEquipsAforament$Codi_districte==0 | 
                           sfEquipsAforament$Codi_barri==0) & 
                         sfEquipsAforament$Desc_tipus_aforament=='bicis')

#obtenir la informació dels barris i districtes
info <- locateItems(sfEquipsAforament, indDesconeguts, municipi, allInfo=FALSE)

sfEquipsAforament[indDesconeguts,]$Codi_districte <- info$codeDist
sfEquipsAforament[indDesconeguts,]$Codi_barri <- info$codeBar

taula(sfEquipsAforament[indDesconeguts,])
```

```{r}
tmp_DistrBarri_0 <- as.data.frame(sfEquipsAforament[sfEquipsAforament$Codi_districte==0 | 
                                                      sfEquipsAforament$Codi_barri==0,])
tmp_DistrBarri_0 <- tmp_DistrBarri_0 %>% dplyr::count(Desc_tipus_aforament)
taula(tmp_DistrBarri_0, full_width=F)
```

A continuació, cal netejar el segon *dataset* que conté el detall de les mesures enregistrades per aquests equips (`dfMesures`). Així doncs, en primer lloc, es descarten aquelles variables que no són interessants per l'estudi.

```{r}
drop <- c('Codi_tipus_dia')
dfMesures <- dfMesures[,!names(dfMesures) %in% drop]
str(dfMesures)
```

En primer lloc, es converteixen les variables qualitatives nominals en factors.

```{r}
var.qualitativa <- c('Id_aforament', 'Desc_tipus_dia')

df <- as.data.frame(dfMesures)
for (v in var.qualitativa){
  dfMesures[,v] <- as.factor(df[,v])
}

summary(dfMesures[,var.qualitativa])
```

Com anteriorment, cal igualar els literals de la variable `Desc_tipus_dia` perquè segueixin un mateix format, tot en minúscules.

```{r}
dfMesures$Desc_tipus_dia <- tolower(dfMesures$Desc_tipus_dia)
dfMesures$Desc_tipus_dia <- droplevels(as.factor(dfMesures$Desc_tipus_dia))

summary(dfMesures[,'Desc_tipus_dia'])
```

Per altra banda, la variable `Desc_tipus_dia` presenta dos valors possibles per indicar que es tracta d'una mesura pressa en un dia laborable, pel que s'unifiquen les dues etiquetes, i finalment, es reordenen els nivells.

```{r}
dfMesures[dfMesures$Desc_tipus_dia=='laborables',]$Desc_tipus_dia <- 'laborable'
dfMesures$Desc_tipus_dia <- droplevels(as.factor(dfMesures$Desc_tipus_dia))
dfMesures$Desc_tipus_dia <- factor(dfMesures$Desc_tipus_dia, levels=c("dilluns", "laborable", "divendres", 
                                                                      "dissabte", "diumenge"))

cat('Valors possibles:', vector.print.with.and(levels(dfMesures$Desc_tipus_dia)))
```

A més, es transforma la variable `Valor_IMD` a una variable quantitativa numèrica, el que genera $21.882$ NA's pel fet que aquests registres contenen el literal *Mesura no disponible*. Aquest fet ja és correcte, doncs hi ha equips de mesura que poden existir i no estar en funcionament durant un cert temps.

```{r warning=FALSE}
dfMesures$Valor_IMD <- as.numeric(dfMesures$Valor_IMD)
NAs.num <- sapply(dfMesures, function(k)sum(is.na(k)))
print(NAs.num[NAs.num!=0])
```

```{r}
taula(head(dfMesures[is.na(dfMesures$Valor_IMD),]), full_width=F)
```

Es pot veure que la distribució de les mesures no enregistrades és força homogènia pel que fa al tipus de dia, així doncs l'eliminació d'aquests registres no afectarà l'anàlisi d'aforament a nivell de tipus de dia de la setmana.

```{r}
na <- dfMesures[is.na(dfMesures$Valor_IMD),]
na <- na %>% dplyr::count(Desc_tipus_dia)
taula(as.data.frame(na), full_width=F)
```

Comentar que aquests registres realment no tenen un IMD vàlid, doncs segons els fitxers figura el literal *Mesura no disponible*. Per aquest motiu, aquests elements són obviats de l'estudi, reduint les observacions a un $85,47%$ del total de registres.

```{r}
dfMesures <- dfMesures[!is.na(dfMesures$Valor_IMD),]
str(dfMesures)
```

Tot seguit, es reanomenen les variables dels dos fitxers perquè totes elles figurin en anglès, estandarditzant així els noms dels diferents fitxers.

```{r}
colnames(sfEquipsAforament) <- c('equipmentId', 'streetName', 'equipmentType', 
                                 'districtId', 'neighborhoodId', 'year', 'geometry')
str(sfEquipsAforament)
```

```{r}
colnames(dfMesures) <- c('year', 'equipmentId', 'month', 'day', 'IMDvalue')
str(dfMesures)
```

Finalment, es crea el primer conjunt a nivell d'equip amb tot el detall de la informació que ha enregistrat. Per això, s'uneixen els dos conjunts de dades tenint en compte l'any de la mesura (`year`) i l'identificador de l'equip que l'ha enregistrat (`equipmentId`).

Si es realitza la unió dels dos conjunts (detall de mesures amb informació dels equips), mantenint tots els registres de mesures, es pot veure que hi ha equips que han enregistrat mesures vàlides, però que no es disposa d'informació del punt de mesura de l'equip en qüestió, pel que no es pot ubicar físicament el dispositiu.

```{r}
temp <- merge(sfEquipsAforament, dfMesures, by=c("year", "equipmentId"), all.y= TRUE)
cat("El conjunt amb totes les mesures d'IMD conté", nrow(temp), 'registres')
```

En concret, es tracta de 60 lectures del 2017 realitzades per l'equip amb `equipmentId==2019` que no es troba en el registre d'equips del 2017.

```{r}
NAs.num <- sapply(temp, function(k)sum(is.na(k)))
print(NAs.num[NAs.num!=0])
```

```{r}
taula(as.data.frame(temp[is.na(temp$equipmentType),] %>% dplyr::count(year, equipmentId)), full_width=F)
```

Així doncs, es realitza la unió dels conjunts obviant els registres de mesura que no es puguin associar a cap punt localitzable d'equip.

```{r}
sfMesuresAfor <- merge(sfEquipsAforament, dfMesures, by=c("equipmentId", "year"), all = FALSE)
str(sfMesuresAfor)
```

Un cop es disposa de tota la informació dels equips i les mesures que han pres, es pot analitzar si les dades presenten valors extrems (*outliers*) mitjançant l'ús de diagrames de caixa.
Aquest càlcul no es pot realitzar abans pel fet que no es disposa del tipus d'equip que ha enregistrat la dada, és a dir, si es tracten de bicis, trànsit o rondes; doncs presenten ordres de magnitud diferents.

```{r fig.width = 10, fig.height = 3}
COLORS <- c("bicis"="#00BA38", "trànsit"="#F8766D", "rondes"="#619CFF")

ggplot(sfMesuresAfor, aes(y=IMDvalue, x=as.factor(year), color=equipmentType)) + 
  geom_boxplot() + 
  facet_wrap(. ~equipmentType, scales="free") + 
  ggtitle("Use of infrastructure by type of track (capacity)") + xlab("Temporality") + ylab("IMD") + 
  scale_color_manual(values=COLORS) + scale_y_continuous(labels=comma_format(big.mark=".", decimal.mark=","))
```

Analitzant en detall la distribució dels valors IMD per tipus de via i per any, es pot veure que realment els valors extrems es troben en un registre de bicis del 2017 que presenta un valor d'IMD 10 vegades superior a la resta, així com en el cas de les rondes del 2018 on un registre conté un valor 5 vegades més gran al bigoti superior del boxplot.

La resta de valors que es troben per sobre els límits dels bigotis, no es consideren valors atípics doncs hi ha una gran quantitat i gradualment es van allunyant aquests valors.

Aquest mateix fet es pot observar analitzant les distribucions següents.

```{r fig.width = 12, fig.height = 7}
sfMesuresAfor$equipmentType <- factor(sfMesuresAfor$equipmentType, levels = c("bicis", "trànsit", "rondes"))
df <- as.data.frame(sfMesuresAfor)[, c('equipmentType', 'year', 'IMDvalue')]
opar <- options(scipen=100)
layout(matrix(c(1, 3, 5, 7,
                2, 4, 6, 8,
                9, 11, 13, 15, 
                10, 12, 14, 16,
                0, 17, 19, 21,
                0, 18, 20, 22), nrow=6, byrow=TRUE),
   widths=c(2,2,2,2), heights=c(2,1,2,1,2,1))

#per cada tipus d'equip i any generar un histograma, un diagrama de densitat i un boxplot amb l'IMD
for(t in levels(df$equipmentType)){
  for (y in YEAR_RANGE){
    v <- df[df$year==y & df$equipmentType==t, 'IMDvalue']

    if(length(v)!=0){
      par(mar=c(1,2,5,2))
      hist(v, col=COLORS[[t]], main=paste0(t, ' of ', y), xlab=NULL, freq=F, border=COLORS[[t]], breaks=75)
      lines(density(v), col="midnightblue", lwd=2)
      
      par(mar=c(0,2,1,2))
      boxplot(v,horizontal=TRUE, col=COLORS[[t]], border="black", axes=0, notch=TRUE)
      lines(rep(mean(v,na.rm=T),2), c(0.5,1.5), col="darkgreen", lwd=2)
    }
  }
}
mtext("Histogram, density and boxplot of IMD", outer=TRUE, cex=1, line=-1.5)
```

Així doncs, es procedeix a localitzar les mesures extremes del conjunt `sfMesuresAfor` per obtenir les dades dels camps necessaris per a identificar el registre únic del conjunt `dfMesures` i eliminar-lo.

```{r}
index <- which((sfMesuresAfor$equipmentType=='bicis' & sfMesuresAfor$year==2017 & sfMesuresAfor$IMDvalue > 10000)
          | (sfMesuresAfor$equipmentType=='rondes' & sfMesuresAfor$year==2018 & sfMesuresAfor$IMDvalue > 200000))
taula(as.data.frame(sfMesuresAfor[index,])[, !names(sfMesuresAfor) %in% c('streetName', 'geometry')])
```

```{r}
indMesures <- which(dfMesures$equipmentId=='20038' & dfMesures$year==2017 
                    & dfMesures$month==11 & dfMesures$day=='dilluns')
dfMesures <- dfMesures[-indMesures,]
cat("Es disposa de", nrow(dfMesures), "mesures d'IMD")
```

```{r}
indMesures <- which(dfMesures$equipmentId=='37-SMD-2' & dfMesures$year==2018 
                    & dfMesures$month==9 & dfMesures$day=='laborable')
dfMesures <- dfMesures[-indMesures,]
cat("Es disposa de", nrow(dfMesures), "mesures d'IMD")
```

A més, també s'elimina del conjunt complet (equips més mesures) `sfMesuresAfor`.

```{r}
sfMesuresAfor <- sfMesuresAfor[-index,]
```

Es pot comprovar que ja no existeixen aquests dos *outliers*.

```{r fig.width = 12, fig.height = 7}
sfMesuresAfor$equipmentType <- factor(sfMesuresAfor$equipmentType, levels = c("bicis", "trànsit", "rondes"))
df <- as.data.frame(sfMesuresAfor)[, c('equipmentType', 'year', 'IMDvalue')]
opar <- options(scipen=100)
layout(matrix(c(1, 3, 5, 7,
                2, 4, 6, 8,
                9, 11, 13, 15, 
                10, 12, 14, 16,
                0, 17, 19, 21,
                0, 18, 20, 22), nrow=6, byrow=TRUE),
   widths=c(2,2,2,2), heights=c(2,1,2,1,2,1))

#per cada tipus d'equip i any generar un histograma, un diagrama de densitat i un boxplot amb l'IMD
for(t in levels(df$equipmentType)){
  for (y in YEAR_RANGE){
    v <- df[df$year==y & df$equipmentType==t, 'IMDvalue']

    if(length(v)!=0){
      par(mar=c(1,2,5,2))
      hist(v, col=COLORS[[t]], main=paste0(t, ' of ', y), xlab=NULL, freq=F, border=COLORS[[t]], breaks=75)
      lines(density(v), col="midnightblue", lwd=2)
      
      par(mar=c(0,2,1,2))
      boxplot(v,horizontal=TRUE, col=COLORS[[t]], border="black", axes=0, notch=TRUE)
      lines(rep(mean(v,na.rm=T),2), c(0.5,1.5), col="darkgreen", lwd=2)
    }
  }
}
mtext("Histogram, density and boxplot of IMD", outer=TRUE, cex=1, line=-1.5)
```

Per altra banda, a partir del conjunt de dades de mesures (`dfMesures`) es calcula la mitjana anual de cada equip de mesura i s'afegeix aquest valor al conjunt de dades d'equips (`sfEquipsAforament`), generant un nou conjunt SF amb el resum d'equips amb el seu IMD mitjà anual (`sfEquipsMitjAfor`).

```{r}
dfMitjanaAforaments <- ddply(dfMesures, .(year, equipmentId), summarise, IMDmean=mean(IMDvalue))
sfEquipsMitjAfor <- merge(sfEquipsAforament, dfMitjanaAforaments, by=c("year", "equipmentId"), all = FALSE)
taula(head(as.data.frame(sfEquipsMitjAfor)))
```



## 2.3. Anàlisi de dades

Tot seguit, s'analitza numèricament l'evolució de la intensitat mitjana diària (IMD) dels diferents tipus de vehicles/trams (rondes, tràfic i bici), assignant-li un color diferent a cadascun.

Així doncs, en primer lloc, es calculen el nombre d'aparells de mesura que existeixen de cada tipus de via, amb el que es pot observar que hi ha hagut un creixement notable de punts d'aforament bicis.

```{r fig.height = 3}
sfEquipsMitjAfor$equipmentType <- factor(sfEquipsMitjAfor$equipmentType, levels = c("bicis","trànsit","rondes"))

dfStats <- ddply(sfEquipsMitjAfor, .(year, equipmentType), summarise, num=length(equipmentId))
ggplot(dfStats, aes(x=year, y=num)) + 
  geom_line(aes(color=equipmentType), size = 1) +
  ggtitle("Evolution of IMD points") + 
  xlab("Temporality") + ylab("Number of IMD points") + ylim(0, max(dfStats$num)+50) + 
  scale_colour_manual(values = COLORS)
```

De forma equivalent a l'estudi anterior, es defineix una funció per calcular la diferència (increment o decrement) que ha patit cada tipus d'aforament en aquest període.

```{r}
#funció per calcular l'increment d'una variable al llarg dels anys. Paràmetres d'entrada:
#   * conjunt amb la variable d'estudi
#   * variable agregadora de dades
#   * any màxim a considerar l'increment
calcDifferenceByYear = function(dfStats, group, valueFilter){
  
  #es calcula, per cada agrupació, la diferència (en percentatge) de valors entre el primer registre i l'últim
  dif <- dfStats %>%
          group_by(dfStats[,group]) %>%
          dplyr::mutate(delta = ((num[year==valueFilter] - num)*100)/num)
  diffPerType <- dif[!duplicated(dif[,group]),]
  
  #es mostra l'agrupació junt amb el seu percentatge diferencial de forma descendent 
  diffPerType <- diffPerType[order(diffPerType$delta, decreasing=TRUE), c(paste0(group), 'delta')]
  diffPerType$delta <- paste(round(diffPerType$delta, 2), "%", sep="")
  
  taula(diffPerType, full_width=F)
}
```

Numèricament s'observa el creixement en les tres modalitats, destacant el cas de les bicis.

```{r}
calcDifferenceByYear(dfStats, "equipmentType", "2020")
```

Separant els aparells per districtes (més les rondes), s'observa el creixement del nombre d'equips de mesura d'aforament de bicis als districtes de Sant Martí i de l'Eixample. 

```{r, fig.width = 17, fig.height = 4}
dfStats <- ddply(sfEquipsMitjAfor, .(year, districtId, equipmentType), summarise, num=length(equipmentId))
YEARS <- c("2017"="17", "2018"="18",  "2019" = "19", "2020" = "20")

LABELS_DISTR <- c("0"="Rondes", "1"=districtes$NOM[1], "2"=districtes$NOM[2], "3"=districtes$NOM[3], 
                                "4"=districtes$NOM[4], "5"=districtes$NOM[5], "6"=districtes$NOM[6], 
                                "7"=districtes$NOM[7], "8"=districtes$NOM[8], "9"=districtes$NOM[9], 
                                "10"=districtes$NOM[10])

ggplot(dfStats, aes(x=year, y=num)) + 
  geom_line(aes(color=equipmentType), size = 1) +
  facet_grid(. ~districtId, labeller=labeller(districtId=LABELS_DISTR)) +
  ggtitle("Evolution of IMD points by district and type") + 
  xlab("Temporality") + ylab("Number of IMD points") + ylim(0, max(dfStats$num)+20)  + 
  scale_x_continuous(labels=YEARS) + scale_color_manual(values=COLORS) +
  theme(legend.position="bottom", panel.spacing=unit(1.25,"lines"))
```

```{r}
calcDifferenceByYear(dfStats[dfStats$equipmentType=='bicis',], "districtId", "2020")
```

Pel que fa als valors d'aforament enregistrats, es pot veure que en el cas dels carrils bici, hi ha alguns dies/trams que destaquen sobre la resta enregistrant valors molt elevats i hi ha una tendència a l'alça, encara que de mitja l'ús disminueix lleugerament.

Pel que fa al trànsit, aquest és estable al llarg dels anys, a excepció del 2020 pel confinament, igual com succeeix en les rondes.

```{r fig.width = 10, fig.height = 3}
ggplot(sfMesuresAfor, aes(y=IMDvalue, x=as.factor(year), color=equipmentType)) + 
  geom_boxplot() + 
  facet_wrap(. ~equipmentType, scales="free") + 
  ggtitle("Use of infrastructure by type of track (capacity)") +
  xlab("Temporality") + ylab("IMD") + scale_color_manual(values=COLORS) + 
  scale_y_continuous(labels=comma_format(big.mark=".", decimal.mark=","))
```

Desglossant els desplaçaments per tipus de dia de la setmana, es pot veure que en tots els casos, els ciutadans realitzen més moviments els dies laborables i entre setmana, mostrant una baixada el dissabte i el diumenge, i aquest patró es manté al llarg dels anys en els diversos tipus de vies.

```{r fig.width = 20, fig.height = 10, out.width="100%"}
dfStats <- ddply(sfMesuresAfor, .(year, equipmentType, day), summarise, IMD=IMDvalue)

ggplot(dfStats, aes(y=IMD, x=day, color=equipmentType)) + 
  geom_boxplot() + 
  facet_wrap(equipmentType~year, scales="free") + 
  ggtitle("Use of infrastructure by type of track and type of day (capacity)") + 
  xlab("Temporality") + ylab("IMD") + scale_color_manual(values=COLORS) + 
  scale_y_continuous(labels=comma_format(big.mark=".", decimal.mark=",")) + theme(legend.position="top")
```

Pel que fa a l'ús de les vies ciclables per districtes, es pot veure que destaca Ciutat Vella, Sants-Montjuïc i l'Eixample amb una mitjana d'IMD de bicis al voltant dels 1.000.

```{r fig.width = 12, fig.height = 5}
dfStats <- ddply(sfEquipsMitjAfor[sfEquipsMitjAfor$equipmentType=='bicis',], .(year, districtId, equipmentType), 
                 summarise, IMD=mean(IMDmean))

ggplot(dfStats, aes(y=IMD, x=as.factor(year), fill=equipmentType)) + 
  geom_bar(stat='identity') + 
  facet_wrap(. ~districtId, labeller=labeller(districtId=LABELS_DISTR), ncol = 5) +
  ggtitle("Use of Bicicle by District")+ xlab("Temporality") + ylab("IMD") +
  scale_x_discrete(labels=YEARS) + scale_y_continuous(labels=comma_format(big.mark=".", decimal.mark=",")) +
  scale_fill_manual(values=COLORS)
```

Pel que als vehicles motoritzats, es pot veure que l'Eixample és el districte més transitat, enregistrant gairebé el doble de vehicles que els districtes perifèrics.

```{r fig.width = 12, fig.height = 5}
dfStats <- ddply(sfEquipsMitjAfor[sfEquipsMitjAfor$equipmentType=='trànsit',], 
                 .(year, districtId, equipmentType), summarise, IMD=mean(IMDmean))

ggplot(dfStats, aes(y=IMD, x=as.factor(year), fill=equipmentType)) + 
  geom_bar(stat='identity') + 
  facet_wrap(. ~districtId, labeller=labeller(districtId=LABELS_DISTR), ncol = 5) +
  ggtitle("Use of Motorized Vehicle by District")+ xlab("Temporality") + ylab("IMD") +
  scale_x_discrete(labels=YEARS) + scale_y_continuous(labels=comma_format(big.mark=".", decimal.mark=",")) +
  scale_fill_manual(values=COLORS)
```

Finalment, es pot veure que la mitja d'intensitat de bicicletes mostra un lleuger descens des del 2017, a causa de l'increment de punts de mesura que es troben ubicats en punts menys concorreguts com els districtes de Sant Martí i Sant Andreu.

```{r fig.width = 10, fig.height=4}
dfStats <- ddply(sfMesuresAfor[sfMesuresAfor$equipmentType=='bicis',], .(month, year, equipmentType), 
                 summarise, IMD=mean(IMDvalue))

dfStats$Temporality <- as.yearmon(paste0(dfStats$year, '-', dfStats$month))

ggplot(dfStats, aes(x=Temporality, y=IMD, fill=equipmentType)) + 
  geom_bar(stat='identity', show.legend = FALSE) +
  ggtitle("Evolution of Bicycle use (mean IMD) with all equipment") + xlab("Temporality") + ylab("IMD") + 
  scale_y_continuous(labels=comma_format(big.mark=".", decimal.mark=",")) + scale_fill_manual(values=COLORS)
```

Si es tenen en compte únicament les mesures preses en aquests 4 anys pels equips originals del 2017, s'aprecia una tendència positiva, disminuint però dins de cada any el seu ús en els mesos d'hivern (desembre, gener, febrer) i el mes principalment festiu d'agost.
Per altra banda, destaca puntualment les dades d'abril del 2020 que va enregistrar nivells mínims des de gener del 2017 pel confinament.

```{r fig.width = 10, fig.height=4}
equips2017 <- sfEquipsMitjAfor[sfEquipsMitjAfor$equipmentType=='bicis' 
                               & sfEquipsMitjAfor$year==2017,]$equipmentId

dfStatsAforament <- ddply(sfMesuresAfor[sfMesuresAfor$equipmentId %in% equips2017,], 
                          .(month, year, equipmentType), summarise, num=mean(IMDvalue))

dfStatsAforament$Temporality <- as.yearmon(paste0(dfStatsAforament$year, '-', dfStatsAforament$month))

ggplot(dfStatsAforament, aes(x=Temporality, y=num, fill=equipmentType)) + 
  geom_bar(stat='identity', show.legend = FALSE) +
  ggtitle("Evolution of Bicycle use (mean IMD) with orignal equipment from 2017") +
  xlab("Temporality") + ylab("IMD") + scale_y_continuous(labels=comma_format(big.mark=".", decimal.mark=",")) + 
  scale_fill_manual(values=COLORS)
```

En general, l'ús de la bici va augmentant i destaca que al 2020, tot i haver-hi uns mesos de confinament, la suma d'IMD és superior als dels anys anteriors, prenent com a referència les mesures preses pels mateixos punts existents en els 4 anys.

```{r fig.width = 8, fig.height=3}
dfStats <- ddply(sfMesuresAfor[sfMesuresAfor$equipmentId %in% equips2017,], .(year, equipmentType), 
                 summarise, IMD=sum(IMDvalue))

ggplot(dfStats, aes(y=IMD, x=as.factor(year), fill=equipmentType)) + 
  geom_bar(stat='identity') + 
  ggtitle("Evolution of Bicycle use (IMD)")+ xlab("Temporality") + ylab("IMD") + 
  scale_y_continuous(labels=comma_format(big.mark=".", decimal.mark=",")) + scale_fill_manual(values=COLORS)
```

En aquest punt es generen les capes a ArcGIS Pro per realitzar l'estudi geoespacial, incloent-hi les mesures dels aforaments, així com els límits administratius.

```{r}
arc.delete(paste0(ARCGIS_PRO_PATH,'mesuresAforaments'))
arc.write(path=paste0(ARCGIS_PRO_PATH,'mesuresAforaments'), data=sfMesuresAfor, validate=TRUE, overwrite=TRUE)

arc.delete(paste0(ARCGIS_PRO_PATH,'equipsAforaments'))
arc.write(path=paste0(ARCGIS_PRO_PATH,'equipsAforaments'), data=sfEquipsMitjAfor, validate=TRUE,overwrite=TRUE)

arc.delete(paste0(ARCGIS_PRO_PATH,'districtes'))
arc.write(path=paste0(ARCGIS_PRO_PATH,'districtes'), data=districtes, validate=TRUE, overwrite=TRUE)

arc.delete(paste0(ARCGIS_PRO_PATH,'barris'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'barris'), data=barris, validate=TRUE, overwrite=TRUE)
```



# 3. Accidentalitat ciclista

En aquesta temàtica interessa estudiar la sinistralitat ciclista, pel que s'obtindrà tota la informació disponible dels accidents i accidentats on s'ha vist involucrada com a mínim una bicicleta. Aquesta visió completa s'utilitzarà per a l'anàlisi estadística, així com per enriquir la visió a AGOL amb la informació dels ciclistes accidentats.

Tot i això, pel càlcul del risc de sinistralitat de bicicletes únicament es necessita disposar d'un conjunt amb els accidents en els quals s'ha vist involucrada una bicicleta, és a dir, a nivell de col·lisió. Aquest conjunt més reduït serà l'utilitzat a ArcGIS Pro per l'anàlisi geoespacial i càlcul del risc dels trams.


## 3.1. Càrrega de les dades

En primer lloc, es defineix el directori pare que conté les dades referents a l'accidentalitat recollida per la Guàrdia Urbana, i es carreguen tots els accidents que s'han produït a Barcelona des del 2017 al 2020.

Aquestes dades es troben en format CSV i incorporen diverses variables amb informació geogràfica, en concret, la `Longitud` i la `Latitud`, que al final s'utilitzaran per generar l'objecte `Simple Features` (SF). Inicialment s'opta per utilitzar un `Data Frame` per comoditat en el tractament de dades.

```{r message=FALSE}
DATA_PATH_ACC <- file.path(DATA_PATH, 'T3.accidents')

#conjunt amb totes les dades dels accidents
dfAccidents <- NULL

#eliminar les coordenades UTM per ser redundants, ja es disposa de longitud i latitud
drop <- c('Coordenada_UTM_X', 'Coordenada_UTM_Y')

#per cada any
for (t in YEAR_RANGE){
  
  #construir el nom i el path del fitxer a carregar tenint en compte l'any de les dades
  fileName <- paste0(t, '_accidents_gu_bcn')
  path <- paste0(DATA_PATH_ACC, '/', 'accidents')
  
  #comprovar si el fitxer existeix en el directori
  if(file.exists(paste0(path, '/', fileName, '.csv'))){
    #carregar les dades del fitxer
    d <- load_data(path, fileName, 'csv')

    #transformacions necessàries per poder processar conjuntament els fitxers
    d$Codi_barri <- as.character(d$Codi_barri)
    d$Codi_districte <- as.numeric(d$Codi_districte)
    d$Dia_setmana <- as.character(d$Dia_setmana)
    d <- d[,!names(d) %in% drop]

     #afegir el nou conjunt de dades al conjunt existent
    dfAccidents <- bind_rows(dfAccidents, d)
  }
}

str(dfAccidents)
```

Aquesta informació dels accidents, que ha enregistrat la Guàrdia Urbana en els últims 4 anys, s'ha d'utilitzar per generar els 2 conjunts comentats inicialment. En ambdós casos, únicament interessa analitzar els accidents i/o accidentats on s'involucren ciclistes, pel que es realitzarà un primer filtratge cercant els involucrats en bici.

```{r}
dfInvolucrats <- NULL

drop <- c('Coordenada_UTM_X', 'Coordenada_UTM_Y', 'Longitud', 'Latitud', 'Dia_setmana', 'Edat')

#per cada any
for (t in YEAR_RANGE){
  
  #construir el nom i el path del fitxer a carregar tenint en compte l'any de les dades
  fileName <- paste0(t, '_accidents_persones_gu_bcn')
  path <- paste0(DATA_PATH_ACC, '/', 'persones_involucrades')
  
  #comprovar si el fitxer existeix en el directori
  if(file.exists(paste0(path, '/', fileName, '.csv'))){
    #carregar les dades del fitxer
    d <- load_data(path, fileName, 'csv')
    
    #filtrar els accidents per treballar només amb els que s'han vist implicats bicicletes
    d <- d[d$Desc_Tipus_vehicle_implicat == 'Bicicleta',]
    
    #eliminar les variables de les coordenades perquè s'uniran els registres per l'expedient de l'accident,
    #així com dades irrellevants per l'estudi i que requereixen un tractament previ per unir els fitxers
    d <- d[,!names(d) %in% drop]
    
    #afegir el nou conjunt de dades al conjunt existent
    dfInvolucrats <- bind_rows(dfInvolucrats, d)
  }
}

str(dfInvolucrats)
```

```{r}
cat("Hi ha hagut", length(unique(dfInvolucrats$Numero_expedient)), 
    "col·lisions on s'ha vist involucrat com a mínim un ciclista, amb un total de", 
    nrow(dfInvolucrats), "ciclistes accidentats (hi ha accidents de múltiples bicis)")
```

Combinant el conjunt `dfAccidents` amb el conjunt `dfInvolucrats` s'obtindran els 2 conjunts d'estudi comentats inicialment (`dfCollisions` i `dfAccidentats`). 

Per una banda, es genera el *dataset* de col·lisions on només interessa conèixer l'accident (`Numero_expedient`), el districte, l'any i la localització.

```{r}
dfCollisions <- match_df(dfAccidents, dfInvolucrats, on="Numero_expedient")
cat("El conjunt dels accidents ciclistes conté", nrow(dfCollisions), 'registres')
```

Per altra banda, s'enriqueix l'estudi amb el detall dels accidentats (ciclistes), així com es creuarà amb els altres fitxers per completar les dades de la causa i tipologia en cada accident.
Cal comentar que els fitxers que complementen la informació dels accidents (involucrats, causa i tipus) contenen moltes dades redundants, doncs aquestes també es troben en el fitxer general d'accidents. Per aquest motiu, només es seleccionarà el subconjunt de variables que realment aportin nova informació, raó per la qual es realitza una primera neteja dels conjunts individuals. 

Comentar que els fitxers dels últims 4 anys d'involucrats han patit modificacions quant a la informació recopilada, per això s'aprecien moltes variables amb gran quantitat de valors absents. A més, també s'ha trobat varietat en les capçaleres (noms de les variables), pel que s'han unificat la majoria de variables abans de la càrrega dels fitxers, per disminuir la feina de tractament de dades.

```{r}
NAs.num <- sapply(dfInvolucrats, function(k)sum(is.na(k)))
print(NAs.num[NAs.num!=0])
```

A continuació es mostren algunes de les variables incompletes. Aquestes són irrellevants per l'estudi del TFM, pel que s'eliminen del conjunt de dades.

```{r}
kable(summary(as.factor(dfInvolucrats$Descripcio_Lloc_atropellament_vianat)), 
      col.names=c('freqüència Lloc atropellament'))
```

```{r}
kable(summary(as.factor(dfInvolucrats$Descripcio_Motiu_despl_vianant)), 
      col.names=c('freqüència Motiu despl vianant'))
```

```{r}
kable(summary(as.factor(dfInvolucrats$Descripcio_Motiu_despl_conductor)), 
      col.names=c('freqüència Motiu despl conductor'))
```
.

En concret, de les dades de persones involucrades interessa mantenir les següents:

```{r}
attr <- c('Numero_expedient', 'Desc_Tipus_vehicle_implicat', 'Descripcio_sexe', 
          'Descripcio_tipus_persona', 'Descripcio_victimitzacio')
dfInvolucrats <- dfInvolucrats[,names(dfInvolucrats) %in% attr]
cat("Variables rellevants:", vector.print.with.and(names(dfInvolucrats)))
```

Tot seguit, s'uneixen les dades dels accidents amb les persones involucrades en cadascun d'ells, utilitzant com a camp d'unió el codi identificatiu de l'expedient, passant a treballar amb un *dataset* de 27 variables a 30, i amb el 8% de registres d'accidents (accidents amb bicicletes involucrades).

```{r}
dfAccidentats <- merge(dfAccidents, dfInvolucrats, by="Numero_expedient", all = FALSE)
str(dfAccidentats)
```

Es realitza el mateix procés pels conjunts de dades que contenen la causa dels accidents.

```{r}
dfCausa <- NULL

#per cada any
for (t in YEAR_RANGE){
  
  #construir el nom i el path del fitxer a carregar tenint en compte l'any de les dades
  fileName <- paste0(t, '_accidents_causes_gu_bcn')
  path <- paste0(DATA_PATH_ACC, '/', 'descripcio_causa')
  
  #comprovar si el fitxer existeix en el directori
  if(file.exists(paste0(path, '/', fileName, '.csv'))){
    #carregar les dades del fitxer
    d <- load_data(path, fileName, 'csv')

    #afegir el nou conjunt de dades al conjunt existent
    dfCausa <- bind_rows(dfCausa, d)
  }
}

str(dfCausa)
```

Aquests fitxers també contenen camps redundants. Es pot apreciar que també hi ha variables que contenen la mateixa informació, però que utilitzen noms diferents en la capçalera dels fitxers, però com es tracta de dades que ja es disposen en el fitxer general d'accidents, no es realitza cap procés de neteja.

```{r}
NAs.num <- sapply(dfCausa, function(k)sum(is.na(k)))
print(NAs.num[NAs.num!=0])
```

Simplement es selecciona la variable `Desc_causa_mediata` (havent modificat el nom en 2 dels 4 fitxers abans de la càrrega) i el nombre d'expedient per realitzar la unió amb el conjunt d'accidents.

```{r}
attr <- c('Numero_expedient', 'Desc_causa_mediata')
dfCausa <- dfCausa[,names(dfCausa) %in% attr]
str(dfCausa)
```

El conjunt d'accidents passa a comptar amb una variable més.

```{r}
dfAccidentats <- merge(dfAccidentats, dfCausa, by="Numero_expedient", all = FALSE)
cat('El conjunt dfAccidentats passa a comptar amb', length(names(dfAccidentats)), 'variables')
```

Finalment, s'incorporen les dades del tipus d'accident que s'ha produït, però únicament per extreure estadístiques a R.

En aquest cas, el fitxer del 2020 conté un format diferent als tres anteriors pel que fa a ús de separadors, doncs utilitza el punt i coma, així com l'ús del limitador de les cadenes de caràcters, en aquest cas inexistent. El fet de no contenir les cometes dobles per emmarcar els textos provoca que no es pugui processar correctament el fitxer. Per aquest motiu, primer s'ha importat a l'OpenOffice per realitzar l'exportació a CSV i estandarditzar el seu format.

```{r}
dfTipus <- NULL
drop <- c('Coordenada_UTM_X', 'Coordenada_UTM_Y', 'Longitud', 'Latitud')

#per cada any
for (t in YEAR_RANGE){
  
  #construir el nom i el path del fitxer a carregar tenint en compte l'any de les dades
  fileName <- paste0(t, '_accidents_tipus_gu_bcn')
  path <- paste0(DATA_PATH_ACC, '/', 'accidents_per_tipologia')
  
  #comprovar si el fitxer existeix en el directori
  if(file.exists(paste0(path, '/', fileName, '.csv'))){
    #carregar les dades del fitxer
    d <- load_data(path, fileName, 'csv')

    #eliminació de variables problemàtiques per poder unir els fitxers
    d <- d[,!names(d) %in% drop]
    
    #afegir el nou conjunt de dades al conjunt existent
    dfTipus <- bind_rows(dfTipus, d)
  }
}

str(dfTipus)
```

Com els fitxers anteriors, ja es disposen de les dades temporals i espacials en el fitxer principal, pel que l'única dada rellevant d'aquest conjunt és el `Tipus_accident`.

```{r}
NAs.num <- sapply(dfTipus[,c('Numero_expedient', 'Tipus_accident', 'Any', 'NK_Any')], function(k)sum(is.na(k)))

if(length(NAs.num[NAs.num!=0])==0){
  cat("No hi ha valors absents en el codi d'expedient, en l'any, ni en el tipus d'accident!")
}else{
  print(NAs.num[NAs.num!=0])
}
```

Així doncs, es tracten els valors absents.

```{r}
dfTipus[is.na(dfTipus$Any),]$Any <- dfTipus[is.na(dfTipus$Any),]$NK_Any

NAs.num <- sapply(dfTipus[,c('Numero_expedient', 'Tipus_accident', 'Any', 'NK_Any')], function(k)sum(is.na(k)))
if(length(NAs.num[NAs.num!=0])==0){
  cat("No hi ha valors absents en el codi d'expedient, en l'any, ni en el tipus d'accident!")
}else{
  print(NAs.num[NAs.num!=0])
}
```

I es seleccionen les variables d'estudi.

```{r}
attr <- c('Numero_expedient', 'Tipus_accident', 'Any')
dfTipus <- dfTipus[,names(dfTipus) %in% attr]
str(dfTipus)
```

Tot seguit, es selecciona el subconjunt de tipus d'accidentalitat d'aquells sinistres en els quals ha col·lisionat un ciclista. Es pot observar que respecte al conjunt inicial d'accidents, hi ha 100 registres més, el que es deu al fet que un accident pot tenir més d'un tipus d'accidentalitat enregistrada. 

```{r}
dfTipusAccidents <- match_df(dfTipus, dfCollisions, on="Numero_expedient")
cat("El conjunt de tipus d'accident conté", nrow(dfTipusAccidents), 'registres')
```

Finalment, es disposa de 3 conjunts de dades:

* `dfCollisions`: amb el nombre d'accidents de bici únics que s'han produït
* `dfAccidentats`: amb el detall dels ciclistes que han patit una col·lisió (hi ha accidents múltiples entre usuaris de bicis)
* `dfTipusAccidents`: amb la informació de quin tipus de xoc s'ha produït en cadascuna de les col·lisions (hi ha col·lisions amb múltiples descripcions de tipologia d'accident)



## 3.2. Neteja i tractament de dades

A continuació, es neteja primer el conjunt `dfCollisions`, cercant si conté valors absents. En aquest cas, es tracta de la variable que conté l'any en el qual van succeir els accidents, doncs és necessària pel càlcul del risc. Aquests valors nuls es deuen al fet que en uns fitxers aquesta dada s'emmagatzema en el camp `Any` i en altres en el `NK_Any`.

```{r}
NAs.num <- sapply(dfCollisions, function(k)sum(is.na(k)))
print(NAs.num[NAs.num!=0])
```

Es procedeix a assignar a la variable `Any` els valors de la variable `NK_Any` per aquells registres que presenten nuls en la primera variable. 

```{r}
dfCollisions[is.na(dfCollisions$Any),]$Any <- dfCollisions[is.na(dfCollisions$Any),]$NK_Any
NAs.num <- sapply(dfCollisions, function(k)sum(is.na(k)))
print(NAs.num[NAs.num!=0])
```

Es redueix la dimensió del conjunt, seleccionant únicament les variables d'estudi i es converteix en un objecte SF.

```{r}
attr <- c('Numero_expedient', 'Codi_districte', 'Nom_districte', 'Any', 'Numero_morts', 'Numero_lesionats_lleus',
          'Numero_lesionats_greus', 'Numero_victimes', 'Numero_vehicles_implicats', 'Longitud', 'Latitud')
dfCollisions <- dfCollisions[,names(dfCollisions) %in% attr]

#convertir en un objecte SF
sfCollisions <- st_as_sf(dfCollisions, coords=c('Longitud', 'Latitud'), crs=st_crs(4326))
#transformar el CRS al legal
sfCollisions <- st_transform(sfCollisions, crs=crs_legal)
str(sfCollisions)
```

Es comproven els valors de les variables numèriques, on observant la distribució de valors, no s'observen *outliers*.

```{r}
taula(do.call(cbind, lapply(as.data.frame(sfCollisions)[,c('Numero_morts', 'Numero_lesionats_lleus', 
                                                           'Numero_lesionats_greus', 'Numero_victimes', 
                                                           'Numero_vehicles_implicats')], summary)), rn=T)
```

Tot seguit, es tracta la variable `Numero_expedient` per eliminar els espais en blanc del final dels codis.

```{r}
sfCollisions$Numero_expedient <- str_trim(sfCollisions$Numero_expedient, side="right")
```

Per altra banda, les variables qualitatives nominals s'han tractat com a cadenes de caràcters en comptes de factors, pel que s'aplica la conversió a factor per poder realitzar càlculs de freqüència d'aparició de cada valor.

```{r}
var.qualitativa <- names(sfCollisions)[sapply(sfCollisions, function(x) (is.character(x)))]

df <- as.data.frame(sfCollisions)
for (v in var.qualitativa){
  sfCollisions[,v] <- as.factor(df[,v])
}

sfCollisions$Codi_districte <- as.factor(sfCollisions$Codi_districte)

str(sfCollisions)
```

A continuació, es netegen els camps que contenen referències a la ubicació dels accidents.

Es pot veure que hi ha 5 accidents (7 registres) que no tenen identificat el lloc on es va produir l'accident (valor `Desconegut`), encara que sí que contenen les coordenades exactes.

```{r}
summary(sfCollisions$Nom_districte)
```

```{r}
taula(sfCollisions[(sfCollisions$Nom_districte=='Desconegut'), c('Numero_expedient', 'Codi_districte', 
                                                                 'Nom_districte', 'Any', 'geometry')])
```

Com es pot veure les coordenades de l'accident *2020S000743* no són vàlides, pel que es procedeix a eliminar aquest accident.

```{r}
sfCollisions <- sfCollisions[sfCollisions$Numero_expedient!='2020S000743',]
```

A continuació, es cerquen els índexs dels registres d'accidents que no tenen informat el districte i/o barri, i per cadascun d'aquests es comprova a partir de la seva geometria (punt) en quin barri ha succeït mitjançant la funció `locateItems`. La informació retornada és incorporada als camps desconeguts d'aquests registres.

```{r}
#es cerquen els índexs dels accidents que no presenten les dades administratives complimentades
indDesconeguts <- which(sfCollisions$Nom_districte=='Desconegut')

info <- locateItems(sfCollisions, indDesconeguts, municipi)

sfCollisions[indDesconeguts,]$Codi_districte <- info$codeDist
sfCollisions[indDesconeguts,]$Nom_districte <- info$nameDist

sfCollisions$Nom_districte <- droplevels(sfCollisions$Nom_districte)
taula(sfCollisions[indDesconeguts, c('Numero_expedient', 'Codi_districte', 'Nom_districte', 'Any', 'geometry')])
```

Es pot veure que ara tots els accidents disposen d'un districte assignat.

```{r}
cat('En total es treballa amb', nrow(sfCollisions), "registres d'accidents (col·lisions), corresponents a",
    length(unique(sfCollisions$Numero_expedient)), "expedients d'accidents")
```

Es comprova si hi ha més accidents que quedin fora dels límits municipals.

```{r}
indexOutMunicipi <- NULL
for (row in 1:nrow(sfCollisions)){
  #si la referència geogràfica (coordenades) de l'accident es troben dins del municipi de Barcelona
  if(!st_within(sfCollisions[row,], municipi, sparse = FALSE)){
    indexOutMunicipi <- append(indexOutMunicipi, row)
  }
}
cat(indexOutMunicipi)
```

En concret, es corresponen als següents:

```{r}
taula(sfCollisions[indexOutMunicipi,c('Numero_expedient', 'Codi_districte', 'Nom_districte', 'Any', 'geometry')])
```

Es valida visualment a ArcGIS Pro si aquests registres realment es troben fora de Barcelona, tot creant tres capes a ArcGIS, una amb el polígon municipal, i 2 amb els accidents, el primer amb els que queden fora del municipi i el segon amb els que es troben dins per validar-ho.

Comentar que quan s'ha executat per primer cop aquesta cerca de punts, s'han localitzat 7 registres d'accidents que no es trobaven dins del polígon de Barcelona, 4 dels quals era perquè no tenien ben informada la geometria (longitud-latitud), doncs els hi mancava el punt decimal per tenir els valors en la mateixa escala. Això s'ha vist a ArcGIS Pro on només es mostraven en el mapa 3 dels 7 punts.

Per això, s'ha modificat manualment en el fitxer aquests registres concrets, incorporant el punt separador decimal, de forma que quan es torna a carregar el fitxer, aquests ja no presenten el valor `POINT EMPTY` en la geometria.

En el cas dels altres 3 accidents, mostrant-los en el mapa es pot veure que es tracten d'accidents que han succeït al carrer que defineix els límits administratius, pel que es consideren vàlids per aquest estudi.

```{r}
arc.delete(paste0(ARCGIS_PRO_PATH, 'municipi'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'municipi'), data=municipi, validate=TRUE, overwrite=TRUE)

arc.delete(paste0(ARCGIS_PRO_PATH, 'accidentsFora'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'accidentsFora'), data=sfCollisions[indexOutMunicipi,], 
          validate=TRUE, overwrite=TRUE)

arc.delete(paste0(ARCGIS_PRO_PATH, 'accidentsDins'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'accidentsDins'), data=sfCollisions[-indexOutMunicipi,], 
          validate=TRUE, overwrite=TRUE)
```

Per últim, es tradueixen els noms dels camps per estandarditzar-ho a l'anglès com en les temàtiques anteriors.

```{r}
colnames(sfCollisions) <- c('caseId', 'districtId', 'districtName', 'year', 'deathNum', 'minorInjuriesNum', 
                            'majorInjuriesNum', 'victimNum', 'vehiclesInvolvedNum',  'geometry')
str(sfCollisions)
```

A continuació, es tracta el conjunt `dfAccidentats`.

```{r}
str(dfAccidentats)
```

Es procedeix a eliminar els camps redundants, com `Dia_setmana` i `Nom_mes`, així com el detall del carrer on s'ha produït cada accident.

```{r}
drop <- c('Codi_carrer', 'Nom_carrer', 'Num_postal', 'Dia_setmana', 'Nom_mes', 'Num_postal_caption', 'Dia_mes')
dfAccidentats <- dfAccidentats[,!names(dfAccidentats) %in% drop]
```

De forma anàloga, es realitza la mateixa neteja que amb el conjunt anterior, tractant la variable `Numero_expedient` per eliminar els espais en blanc del final dels codis i localitzar les variables amb valors absents.

```{r}
dfAccidentats$Numero_expedient <- str_trim(dfAccidentats$Numero_expedient, side="right")

NAs.num <- sapply(dfAccidentats, function(k)sum(is.na(k)))
print(NAs.num[NAs.num!=0])
```

Es procedeix a assignar a la variable `Any` els valors de la variable `NK_Any` per aquells registres que presenten nuls en la primera variable. 

```{r}
dfAccidentats[is.na(dfAccidentats$Any),]$Any <- dfAccidentats[is.na(dfAccidentats$Any),]$NK_Any
NAs.num <- sapply(dfAccidentats, function(k)sum(is.na(k)))
print(NAs.num[NAs.num!=0])
```

Es redueix la dimensió del conjunt, eliminant les variables irrellevants i convertint el conjunt en un SF.

```{r}
dfAccidentats <- dfAccidentats[,!names(dfAccidentats) %in% c('NK_Any', 'Desc_Tipus_vehicle_implicat')]

#convertir en un objecte SF
sfAccidentats <- st_as_sf(dfAccidentats, coords=c('Longitud', 'Latitud'), crs=st_crs(4326))
#transformar el CRS al legal
sfAccidentats <- st_transform(sfAccidentats, crs=crs_legal)
str(sfAccidentats)
```

Per altra banda, es transformen les variables qualitatives nominals a factors.

```{r}
var.qualitativa <- names(sfAccidentats)[sapply(sfAccidentats, function(x) (is.character(x)))]

df <- as.data.frame(sfAccidentats)
for (v in var.qualitativa){
  sfAccidentats[,v] <- as.factor(df[,v])
}

sfAccidentats$Codi_districte <- as.factor(sfAccidentats$Codi_districte)

str(as.data.frame(sfAccidentats)[, var.qualitativa])
```

Per altra banda, es pot comprovar que la variable `Descripcio_tipus_dia` té variabilitat nul·la, pel que es pot prescindir de la variable.

```{r}
summary(as.data.frame(sfAccidentats)[,c('Descripcio_tipus_dia')])
```

```{r}
sfAccidentats <- sfAccidentats[,!names(sfAccidentats) %in% c('Descripcio_tipus_dia')]
```

A continuació, es cerquen nivells `Desconeguts` en la ubicació dels accidentats.

```{r}
desconeguts.num <- sapply(as.data.frame(sfAccidentats)[,c('Nom_districte', 'Nom_barri')], 
                          function(k)sum(k=='Desconegut'))
print(desconeguts.num[desconeguts.num!=0])
```

Es cerquen els registres d'accidentats que no contenen correctament informades les dades de localització.

```{r}
taula(sfAccidentats[(sfAccidentats$Nom_districte=='Desconegut' | sfAccidentats$Nom_barri=='Desconegut'), 
              c('Numero_expedient', 'Codi_districte', 'Nom_districte', 'Codi_barri', 'Nom_barri', 'Any')])
```

Com es pot veure les coordenades de l'accident *2020S000743* no són vàlides, pel que es procedeix a eliminar aquest accident.

```{r}
sfAccidentats <- sfAccidentats[sfAccidentats$Numero_expedient!='2020S000743',]
```

A continuació, es cerquen els índexs dels registres d'accidents que no tenen informat el districte i/o barri, i per cadascun d'aquests es comprova a partir de la seva geometria (punt) en quin barri ha succeït mitjançant la funció `locateItems`. La informació retornada és incorporada als camps desconeguts d'aquests registres.

```{r}
#cerca dels índexs dels accidentats que no presenten les dades administratives complimentades
indDesconeguts <- which(sfAccidentats$Nom_districte=='Desconegut' | sfAccidentats$Nom_barri=='Desconegut')

#obtenir les dades de barri i districte
info <- locateItems(sfAccidentats, indDesconeguts, municipi)

#incorporar les dades calculades als accidentats amb valor desconegut
sfAccidentats[indDesconeguts,]$Codi_districte <- info$codeDist
sfAccidentats[indDesconeguts,]$Nom_districte <- info$nameDist
sfAccidentats[indDesconeguts,]$Codi_barri <- info$codeBar
sfAccidentats[indDesconeguts,]$Nom_barri <- info$nameBar

sfAccidentats$Nom_barri <- droplevels(sfAccidentats$Nom_barri)
sfAccidentats$Nom_districte <- droplevels(sfAccidentats$Nom_districte)

taula(sfAccidentats[indDesconeguts,c('Numero_expedient', 'Codi_districte', 'Nom_districte', 
                                     'Codi_barri', 'Nom_barri', 'Any')])
```

Es pot veure que ara tots els accidentats disposen d'un barri i un districte assignat.

```{r}
cat('En total es treballa amb', nrow(sfAccidentats), "ciclistes accidentats, involucrats en total en", 
    length(unique(sfAccidentats$Numero_expedient)), "accidents")
```

Finalment, es realitza una estadística descriptiva per acabar de validar el contingut de les variables.

```{r}
summary(as.data.frame(sfAccidentats[,'Numero_expedient']))
```

```{r}
sfAccidentats$Codi_districte <- as.factor(sfAccidentats$Codi_districte)
summary(as.data.frame(sfAccidentats)[,2:5])
```

```{r}
summary(as.data.frame(sfAccidentats)[6:9])
```

```{r}
summary(as.data.frame(sfAccidentats)[,c('Descripcio_causa_vianant', 'Descripcio_sexe', 
                                        'Descripcio_tipus_persona', 'Desc_causa_mediata', 
                                        'Descripcio_victimitzacio')])
```

Es pot veure que el `Codi_barri` ha patit un canvi de format en el fitxer del 2020, el qual està format per tres codis separats per guions. En aquest cas, el codi identificatiu del barri es correspon als últims dígits, pel que s'aplica una transformació per adequar-lo al format dels altres registres.

```{r}
sfAccidentats$Codi_barri <- as.factor(substring(as.character(sfAccidentats$Codi_barri), 
                                      regexpr("-[0-9]?[0-9]$", as.character(sfAccidentats$Codi_barri))+1))
summary(as.data.frame(sfAccidentats)[,c('Codi_barri', 'Nom_barri')])
```

En el cas del camp `Descripcio_victimitzacio` es simplifiquen els nivells possibles per destacar en quin estat es van trobar les persones involucrades, obviant els subnivells d'afectació de l'accidentat.

```{r}
levels(sfAccidentats$Descripcio_victimitzacio)
```

```{r}
#simplificar els subtipus de ferits, mantenint únicament l'estat del ferit (obviant l'aclariment)
sfAccidentats$Descripcio_victimitzacio <- as.factor(gsub(':.*', "", sfAccidentats$Descripcio_victimitzacio, 
                                                         ignore.case=T))

#afegir els 2 nous nivells que substituiran: Il.lcs i Mort (dins 24h posteriors accident)
levels(sfAccidentats$Descripcio_victimitzacio) <- c(levels(sfAccidentats$Descripcio_victimitzacio), 
                                                    'Il·les', 'Mort')
sfAccidentats[sfAccidentats$Descripcio_victimitzacio=='Il.lcs',
              ]$Descripcio_victimitzacio <- as.factor('Il·les')
sfAccidentats[sfAccidentats$Descripcio_victimitzacio=='Mort (dins 24h posteriors accident)',
              ]$Descripcio_victimitzacio <- as.factor('Mort')

#recalcular els nivells de la variable
sfAccidentats$Descripcio_victimitzacio <- droplevels(sfAccidentats$Descripcio_victimitzacio)
levels(sfAccidentats$Descripcio_victimitzacio)
```

I es comproven els nivells possibles de `Desc_causa_mediata`.

```{r}
levels(sfAccidentats$Desc_causa_mediata)
```

Per últim, es tradueixen els noms dels camps per estandarditzar-ho a l'anglès com en les temàtiques anteriors.

```{r}
colnames(sfAccidentats) <- c('caseId', 'districtId', 'districtName', 'neighborhoodId', 'neighborhoodName', 
                             'day', 'year', 'month', 'hour', 'shift', 'pedestrianCause', 'deathNum', 
                             'minorInjuriesNum', 'majorInjuriesNum', 'victimNum', 'vehiclesInvolvedNum', 
                             'gender', 'personType', 'victimizationType', 'mediataCause', 'geometry')
str(sfAccidentats)
```

Finalment, es tracta el conjunt restant (`dfTipusAccidents`), on només és necessari convertir les variables qualitatives a factors i aplicar la transformació al codi d'expedient.

```{r}
str(dfTipusAccidents)
```

```{r}
#transformar a factor les variables qualitatives
var.qualitativa <- names(dfTipusAccidents)[sapply(dfTipusAccidents, function(x) (is.character(x)))]

df <- as.data.frame(dfTipusAccidents)
for (v in var.qualitativa){
  dfTipusAccidents[,v] <- as.factor(df[,v])
}

#eliminar els espais en blanc del codi d'expedient
dfTipusAccidents$Numero_expedient <- str_trim(dfTipusAccidents$Numero_expedient, side="right")
#mostrar els tipus d'accidentalitat
levels(dfTipusAccidents$Tipus_accident)
```

Per últim es tradueix el nom de les variables.

```{r}
colnames(dfTipusAccidents) <- c('caseId', 'year', 'accidentType')
str(dfTipusAccidents)
```

Comentar que per calcular l'RCb, és necessari disposar de la infraestructura de carrils bici, doncs es necessita disposar de mesures IMD de bicis, i aquests equips únicament es troben en els carrils bici. Així doncs, com el risc de patir un accident es calcularà a nivell anual, es treballarà amb l'última foto de la infraestructura de cada any, és a dir, la del quart trimestre.

```{r}
sfCarrilBici <- sfInfraestr[sfInfraestr$type=='carril bici' & sfInfraestr$quarter=='4T',]
```



## 3.3. Anàlisi de dades

Es procedeix a analitzar estadísticament amb R els accidents ocorreguts entre el 2017 i 2020 a Barcelona on s'han vist implicats usuaris ciclistes.

```{r}
cat("En total, entre el 2017 i 2020, s'han produït", length(sfCollisions$caseId), "accidents/col·lisions on s'ha vist involucrat com a mínim un ciclista i hi ha hagut", length(sfAccidentats$caseId), "ciclistes accidentats")
```

A continuació, es mostra l'evolució del nombre d'accidents tenint en compte el mes com a unitat temporal.

Es pot apreciar un comportament cíclic, on els mesos que presenten festivitats (desembre, gener, agost i setembre) enregistren pràcticament la meitat d'accidents que els pics corresponents als mesos de maig-juny i octubre. Això es deu al fet que els mesos amb festivitats i amb pitjor temps climatològic (mesos més freds i més calorosos) hi ha un índex mitjà de bicis inferior a la resta de l'any (aforament). Tot i això, aquest comportament cíclic es manté estable any rere any, sense patir pel creixement que ha experimentat l'ús de la infraestructura.

Així doncs, s'observa un comportament a la baixa en el nombre total d'accidents de bicis, en concret disminueix un 18%. Es podria pensar que està relacionat amb una millora de la infraestructura ciclable, però no es pot afirmar perquè l'aparició dels VMP al 2018 ha generat gran quantitat d'accidents. En particular, analitzant els accidents dels VMPs, el seu creixement és desmesurat, ja que en dos anys gairebé es tripliquen el nombre d'accidents amb la seva implicació, arribant als més de 600 casos d'accidents al 2020, mentre que les bicis al 2020 enregistren poc més de 700.

Per tant, no es pot afirmar que la infraestructura ha millorat quant a seguretat, doncs l'aforament enregistra un increment d'ús, però ha aparegut un nou possible usuari de la infraestructura, el qual genera més sinistralitat. A més, en les mesures d'aforament, no es pot diferenciar si hi ha menys bicis i més VMP circulant pels carrils, i per això menys accidents amb implicació de bicis, o si els VMP circulen fora de l'abast dels equips de mesura de bicis i l'increment d'ús és exclusiu d'aquestes. Per això, s'hauria de realitzar un estudi complementari dels accidents VMP per analitzar per on circulen en funció dels punts de la seva sinistralitat, però en aquest moment queda fora de l'abast d'aquest TFM.

Per altra banda, es pot veure la caiguda dràstica d'accidentats de bicis de març-abril-maig del 2020 degut al confinament i les mesures restrictives.

A continuació, es mostren les evidències que permeten extreure les conclusions anteriors.

```{r fig.width = 10}
dfStatsAccidents <- ddply(sfAccidentats, .(month, year), summarise, num=length(unique(caseId)))
dfStatsAccidents$Temporality <- as.yearmon(paste0(dfStatsAccidents$year, '-', dfStatsAccidents$month))

ggplot(dfStatsAccidents, aes(x=Temporality, y=num)) + 
  geom_bar(stat='identity') +
  ggtitle("Evolution of Accidents (cycling)")+ xlab("Temporality") + ylab("Number of accidents")
```

Per comparar en una mateixa gràfica els dos conceptes (accidents i aforaments), es combinen les estadístiques individuals tot normalitzant el valor numèric d'accidents i aforaments en cada cas per visualitzar-ho en la mateixa escala i obtenir el patró.

```{r}
dfStatsAforament <- dfStatsAforament[,!names(dfStatsAforament) %in% c('equipmentType')]
dfStatsAforament$data <- 'Aforaments'
dfStatsAforament$num <- rescale(dfStatsAforament$num)

dfStatsAccidents$data <- 'Accidents'
dfStatsAccidents$num <- rescale(dfStatsAccidents$num)

comp <- rbind(dfStatsAccidents, dfStatsAforament)
taula(head(comp))
```

```{r fig.width = 12, fig.height = 5}
ggplot(comp, aes(x=Temporality,y=num,group=data)) +
    geom_area(aes(fill=data),position="identity") +
    scale_fill_manual(values = alpha(c("#000000","#00BA38"), .25)) +
    labs(title="Comparative between Accidents and Infraestructure use (Cycling) ",
        y="Number of accidents or use (normalized)", x="Temporality")
```

Es carreguen les dades de persones involucrades en accidents per comparar el nombre d'accidents/col·lisions on s'ha vist implicada una bici amb el nombre d'accidents/col·lisions amb implicació d'un VMP.

```{r}
dfVMP <- NULL

get <- c('Numero_expedient', 'Desc_Tipus_vehicle_implicat', 'Any')

#per cada any
for (t in YEAR_RANGE){
  
  #construir el nom i el path del fitxer a carregar tenint en compte l'any de les dades
  fileName <- paste0(t, '_accidents_persones_gu_bcn')
  path <- paste0(DATA_PATH_ACC, '/', 'persones_involucrades')
  
  #comprovar si el fitxer existeix en el directori
  if(file.exists(paste0(path, '/', fileName, '.csv'))){
    #carregar les dades del fitxer
    d <- load_data(path, fileName, 'csv')

    #seleccionar les variables d'interès
    d <- d[,names(d) %in% get]
    
    #afegir el nou conjunt de dades al conjunt existent
    dfVMP <- bind_rows(dfVMP, d)
  }
}

#seleccionar els registres d'accidentats que es corresponguin a bicis i VMPs
vehicles <- c('Bicicleta', 'Veh. mobilitat personal amb motor', 'Veh. mobilitat personal sense motor')
dfVMP <- dfVMP[dfVMP$Desc_Tipus_vehicle_implicat %in% vehicles,]

#unificar els nivells dels VMP en una mateixa categoria
dfVMP$Desc_Tipus_vehicle_implicat <- as.factor(dfVMP$Desc_Tipus_vehicle_implicat)
levels(dfVMP$Desc_Tipus_vehicle_implicat) <- c(levels(dfVMP$Desc_Tipus_vehicle_implicat), 'VMP')
dfVMP[dfVMP$Desc_Tipus_vehicle_implicat=='Veh. mobilitat personal amb motor',
      ]$Desc_Tipus_vehicle_implicat <- as.factor('VMP')
dfVMP[dfVMP$Desc_Tipus_vehicle_implicat=='Veh. mobilitat personal sense motor',
      ]$Desc_Tipus_vehicle_implicat <- as.factor('VMP')

#recalcular els nivells de la variable
dfVMP$Desc_Tipus_vehicle_implicat <- droplevels(dfVMP$Desc_Tipus_vehicle_implicat)

str(dfVMP)
```

Es mostra l'evolució dels accidents en els quals s'han vist involucrades bicis i VMPs.

```{r fig.width = 5, fig.height = 4}
dfStats <- ddply(dfVMP, .(Any, Desc_Tipus_vehicle_implicat), summarise, num=length(unique(Numero_expedient)))
dfStats$year <- dfStats$Any

ggplot(dfStats, aes(y=num, x=Any, fill=Desc_Tipus_vehicle_implicat)) + 
  geom_bar(stat='identity', position=position_dodge(width = 0.9, preserve = "single")) + 
  ggtitle("Evolution of Accidents (cycling and VMP) ") + xlab("Temporality") + ylab("Number of accidents") +
  scale_y_continuous(labels=comma_format(big.mark=".", decimal.mark=",")) + 
  scale_fill_manual('Vehicle involved', values=(c("Bicicleta"="#00BA38", "VMP"="#9738FC"))) + 
  theme(axis.text=element_text(size=8), legend.position="top")
```

```{r}
calcDifferenceByYear(dfStats, "Desc_Tipus_vehicle_implicat", "2020")
```

Pel que fa a la distribució dels accidents per tipus de dia de la setmana, es pot apreciar també una disminució els caps de setmana, coincidint amb la disminució de tràfic, tant de bici com motoritzat.

```{r fig.width = 16, fig.height = 5}
dfStats <- ddply(sfAccidentats, .(year, day), summarise, num=length(unique(caseId)))
dfStats$day <- factor(dfStats$day, levels = c("Dilluns", "Dimarts", "Dimecres", "Dijous", 
                                              "Divendres", "Dissabte", "Diumenge"))

ggplot(dfStats, aes(y=num, x=day)) + 
  geom_bar(stat='identity') + 
  facet_grid(.~year) + 
  ggtitle("Evolution of Accidents (cycling) ") + xlab("Temporality") + ylab("Number of accidents") + 
  scale_color_manual(values=COLORS) + scale_y_continuous(labels=comma_format(big.mark=".", decimal.mark=",")) +
  theme(axis.text=element_text(size=8))
```

Respecte al moment en el qual es produeixen els accidents, la gran majoria d'ells es donen a la tarda, seguit del matí.

```{r fig.width = 10, fig.height = 3}
dfStats <- ddply(sfAccidentats, .(year, shift), summarise, num=length(unique(caseId)))
dfStats$shift <- factor(dfStats$shift, levels = c("Matí", "Tarda", "Nit"))

ggplot(dfStats, aes(y=num, x=shift)) + 
  geom_bar(stat='identity') + 
  facet_grid(.~year) + 
  ggtitle("Evolution of Accidents (cycling) ") + xlab("Temporality") + ylab("Number of accidents") + 
  scale_color_manual(values=COLORS) + scale_y_continuous(labels=comma_format(big.mark=".", decimal.mark=","))
```

Per altra banda, per comparar el nombre de col·lisions amb implicació de bicicletes de forma equivalent a l'estudi de l'ASPB, es calcula la quantitat d'accidents que han ocorregut anualment.

Es pot veure que al 2017 es va produir el pic d'accidents del final de la dècada, i s'observa un canvi de tendència, doncs els primers 4 anys (2010-2014) el nombre d'accidentats amb implicacions de ciclistes anava a l'alça, mentre que en els últims 4 (2017-2020) el nombre d'accidents ha anat disminuint, arribant a valors inferiors al 2013.

Tot i això, s'ha de tenir en compte que l'últim any és anòmal pel que fa a la mobilitat. 

```{r fig.height=4}
dfStats <- ddply(sfCollisions, ~year, summarise, num=length(caseId))

ggplot(dfStats, aes(x=year, y=num)) + geom_line(size = 1) + geom_point() +
  geom_text(aes(label = num), vjust = "inward", hjust = "inward", show.legend = FALSE) +
  ggtitle("Evolution of Accidents (cycling)")+ xlab("Temporality") + ylab("Number of accidents")+ ylim(0, max(dfStats$num)+50)
```

Separant els accidents per districte, es pot veure que el centre de Barcelona (Eixample) és on s'han produït la gran majoria d'accidents.

En general tots els districtes han millorat el nombre d'accidents de forma homogènia.

```{r}
dfStats <- ddply(sfCollisions, .(year, districtName), summarise, num=length(caseId))
ggplot(dfStats, aes(x=year, y=num)) + geom_line(aes(color=districtName), size = 1) +
  ggtitle("Evolution of Accidents (cycling)") + xlab("Temporality") + ylab("Number of accidents") + 
  ylim(0, max(dfStats$num)+50)
```

Respecte a les col·lisions on s'han vist involucrats ciclistes (conductors i passatgers), obviant els vianants afectats, segueix la tendència de què la gran majoria són accidents/col·lisions lleus.

```{r fig.height=4}
COLORS <- c("Ferit greu"="#1D55BE", "Ferit lleu"="#1FBE1D", "Mort"="#F42019", 
            "Desconegut"="#818181", "Il·les"="#D8DF09")

sfAccidentatsConductors <- sfAccidentats[sfAccidentats$personType=='Conductor' | 
                                           sfAccidentats$personType=='Passatger',]
dfStats <- ddply(sfAccidentatsConductors, .(year, victimizationType), summarise, num=length(unique(caseId)))

dfStats$victimizationType <- factor(dfStats$victimizationType, levels = c("Il·les", "Ferit lleu", "Ferit greu", 
                                                                          "Mort", "Desconegut"))
ggplot(dfStats, aes(x=year, y=num)) + 
  geom_line(aes(color=victimizationType), size = 1) + 
  geom_point(aes(colour = victimizationType)) + 
  geom_text(aes(label = num), vjust = "inward", hjust = "inward", show.legend = FALSE) +
  ggtitle("Number of traffic collisions with injured cyclists (not pedestrian)") + 
  xlab("Temporality") + ylab("Number of accidents") + ylim(0, max(dfStats$num)+20) +
  scale_colour_manual('Victimization', values = COLORS)
```

Tot seguit, s'analitza la gravetat dels ciclistes accidentats (conductors i passatgers), és a dir, si un accident ha sigut múltiple de bicis i hi ha més d'un afectat del mateix tipus, es compten de forma individual en el càlcul.

A partir de la gràfica, es pot dir que segueix sent lleu la gravetat dels ciclistes implicats, doncs el nombre de morts és pràcticament zero, i els greus no arriben al 2% del total d'accidentats.

```{r fig.height=4}
dfStats <- ddply(sfAccidentats[sfAccidentats$personType %in% c('Conductor', 'Passatger'),], .(year, victimizationType), 
                 summarise, num=length(caseId))
dfStats$victimizationType <- factor(dfStats$victimizationType, levels = c("Il·les", "Ferit lleu", "Ferit greu", 
                                                                          "Mort", "Desconegut"))

ggplot(dfStats, aes(x=year, y=num)) + 
  geom_line(aes(color=victimizationType), size = 1) + 
  geom_point(aes(colour = victimizationType)) +
  geom_text(aes(label = num), vjust = "inward", hjust = "inward", show.legend = FALSE) +
  ggtitle("Number of injured cyclists in traffic collisions") + 
  xlab("Temporality") + ylab("Number of involved cyclists") + ylim(0, max(dfStats$num)+20) +
  scale_colour_manual('Victimization', values = COLORS)
```

Per altra banda, s'observa que la majoria dels accidents on s'ha vist implicat un vianant, no han sigut provocats pel mateix vianant (destaca al 2020 on sembla que aquesta mesura es correspongui als valors de la categoria `Desconegut`).

Comentar que s'aprecia un augment del nombre de casos la causa dels quals és `Transitar a peu per la calçada`, que es pot correspondre amb l'augment de vies compartides entre aquests dos tipus d'usuaris (ciclistes i vianants), arran de l'augment de les vies ciclables.

```{r fig.width = 8, fig.height = 3}
sfAccidentatVianant <- sfAccidentats[sfAccidentats$personType=='Vianant',]

dfStats <- ddply(sfAccidentatVianant, .(year, pedestrianCause), summarise, num=length(unique(caseId)))

ggplot(dfStats, aes(fill=pedestrianCause, y=num, x=reorder(pedestrianCause,num))) + 
  geom_bar(position="dodge", stat="identity") +
  ggtitle("Cause of pedestrian accident in bicycle collisions") +
  facet_grid(. ~year) +
  theme(legend.position="none") + xlab("") + coord_flip() + theme(panel.spacing = unit(1.25, "lines"))

```

```{r}
calcDifferenceByYear(dfStats[dfStats$pedestrianCause %in% c('Creuar per fora pas de vianants', 
                                                            'Desobeir el senyal del semàfor', 'Altres', 
                                                            'Transitar a peu per la calçada'),], 
                     "pedestrianCause", "2020")
```

Altrament, la causa de la majoria d'accidents on s'ha vist involucrat un ciclista ha sigut per alcoholèmia, seguit del mal estat de la calçada.

```{r fig.width = 8, fig.height = 3}
sfAccidentsWithCause <- sfAccidentats[sfAccidentats$mediataCause!='No hi ha causa mediata',]
sfAccidentsWithCause$mediataCause <- droplevels(sfAccidentsWithCause$mediataCause)

dfStats <- ddply(sfAccidentsWithCause, .(year, mediataCause), summarise, num=length(unique(caseId)))

ggplot(dfStats, aes(fill=mediataCause, y=num, x=reorder(mediataCause,num))) + 
  geom_bar(position="dodge", stat="identity") +
  ggtitle("Cause of bicycle collision") +
  facet_grid(. ~year) +
  theme(legend.position="none") +
  xlab("") + coord_flip() + theme(panel.spacing = unit(1.25, "lines"))
``` 

Per últim, el tipus de col·lisions predominen per ser fronto-lateral, el que indica que succeeixen en cruïlles, seguit d'atropellaments en general i col·lisions laterals i frontals. Aquestes dades es poden validar observant els punts d'accidents a ArcGIS Pro.

El tipus de col·lisions és estable en el temps, a excepció del nombre d'atropellaments del 2020 que s'ha reduït lleugerament.

```{r fig.width = 8, fig.height = 4}
dfStats <- ddply(dfTipusAccidents, .(year, accidentType), summarise, num=length(unique(caseId)))

ggplot(dfStats, aes(fill=accidentType, y=num, x=reorder(accidentType,num))) + 
  geom_bar(position="dodge", stat="identity") +
  ggtitle("Type of bicycle collision") +
  facet_grid(. ~year) +
  theme(legend.position="none") +
  xlab("") + coord_flip() + theme(panel.spacing = unit(1.25, "lines"))
```

Finalment, es traslladen les dades de col·lisions, dels carrils bici i de les mesures d'IMD al producte d'ArcGIS Pro mitjançant el connector R-ArcGIS Bridge, pel càlcul del risc.

```{r}
arc.delete(paste0(ARCGIS_PRO_PATH, 'collisions'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'collisions'), data=sfCollisions, validate=TRUE, overwrite=TRUE)
```

```{r}
arc.delete(paste0(ARCGIS_PRO_PATH, 'carrilBici_2017'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'carrilBici_2017'), data=sfCarrilBici[sfCarrilBici$year==2017,], 
          validate=TRUE, overwrite=TRUE)

arc.delete(paste0(ARCGIS_PRO_PATH, 'carrilBici_2018'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'carrilBici_2018'), data=sfCarrilBici[sfCarrilBici$year==2018,], 
          validate=TRUE, overwrite=TRUE)

arc.delete(paste0(ARCGIS_PRO_PATH, 'carrilBici_2019'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'carrilBici_2019'), data=sfCarrilBici[sfCarrilBici$year==2019,], 
          validate=TRUE, overwrite=TRUE)

arc.delete(paste0(ARCGIS_PRO_PATH, 'carrilBici_2020'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'carrilBici_2020'), data=sfCarrilBici[sfCarrilBici$year==2020,], 
          validate=TRUE, overwrite=TRUE)
```

```{r}
arc.delete(paste0(ARCGIS_PRO_PATH, 'equipsIMD'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'equipsIMD'), 
          data=sfEquipsMitjAfor[sfEquipsMitjAfor$equipmentType!='rondes',], 
          validate=TRUE, overwrite=TRUE)
```

```{r}
arc.delete(paste0(ARCGIS_PRO_PATH, 'carrilsBici_base'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'carrilsBici_base'), data=sfCarrilBici, validate=TRUE, overwrite=TRUE)
```

```{r}
arc.delete(paste0(ARCGIS_PRO_PATH, 'collisions_2017'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'collisions_2017'), data=sfCollisions[sfCollisions$year==2017,], 
          validate=TRUE, overwrite=TRUE)

arc.delete(paste0(ARCGIS_PRO_PATH, 'collisions_2018'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'collisions_2018'), data=sfCollisions[sfCollisions$year==2018,], 
          validate=TRUE, overwrite=TRUE)

arc.delete(paste0(ARCGIS_PRO_PATH, 'collisions_2019'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'collisions_2019'), data=sfCollisions[sfCollisions$year==2019,], 
          validate=TRUE, overwrite=TRUE)

arc.delete(paste0(ARCGIS_PRO_PATH, 'collisions_2020'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'collisions_2020'), data=sfCollisions[sfCollisions$year==2020,], 
          validate=TRUE, overwrite=TRUE)
```



# 4. Qualitat de l'aire

## 4.1. Càrrega de les dades

Durant la descàrrega del fitxer, s'ha preseleccionat mitjançant un filtre les dades dels contaminants d'interès, és a dir, les enregistrades a Barcelona entre els anys 2017 i 2020, pels 5 tipus de contaminants utilitzats pel càlcul de l'ICQA.

Les dades es carreguen en un *dataframe* per agilitzar el seu tractament.

```{r message=FALSE}
DATA_PATH_US <- file.path(DATA_PATH, 'T4.qualitat_aire')

#conjunt amb totes les dades de qualitat
dfQualitatAire <- NULL

fileName <- 'Qualitat_aire_XVPCA_2017_2020'

#comprovar si el fitxer existeix en el directori
if(file.exists(paste0(DATA_PATH_US, '/', fileName, '.csv'))){
    #carregar les dades del fitxer
    d <- load_data(DATA_PATH_US, fileName, 'csv')

    #afegir el nou conjunt de dades al conjunt existent
    dfQualitatAire <- bind_rows(dfQualitatAire, d)
}

str(dfQualitatAire)
```



## 4.2. Neteja i tractament de dades

En primer lloc, es converteixen les variables detectades durant la càrrega com a caràcters a factors (variables qualitatives).

```{r}
var.qualitativa <- names(dfQualitatAire)[sapply(dfQualitatAire, function(x) (is.character(x)))]

df <- as.data.frame(dfQualitatAire)
for (v in var.qualitativa){
  dfQualitatAire[,v] <- as.factor(df[,v])
}

str(as.data.frame(dfQualitatAire)[,var.qualitativa])
```

Es decideix dividir el conjunt inicial en 2 subconjunts, doncs com en el cas dels aforaments, es vol comptar amb una visió global de la qualitat de l'aire a nivell d'estació, i per altra banda, disposar de totes les mesures enregistrades per tipus de dia.

Així doncs, en primer lloc es seleccionen les variables pròpies de les estacions. 

```{r}
attr <- c('CODI.EOI', 'NOM.ESTACIO', 'TIPUS.ESTACIO', 'AREA.URBANA', 'CODI.INE', 'MUNICIPI', 
          'CODI.COMARCA', 'NOM.COMARCA', 'LATITUD', 'LONGITUD', 'ALTITUD', 'GEOREFERENCIA')
dfEstacions <- dfQualitatAire[,(names(dfQualitatAire) %in% attr)]
dfEstacions <- dfEstacions %>% distinct()
summary(dfEstacions)
```

Es descarta la variable `AREA.URBANA`, doncs totes les estacions són urbanes a excepció de l'Observatori Fabra que està etiquetat com a `suburban` i `peri-urban`, així com `CODI.INE`, `MUNICIPI`, `CODI.COMARCA` i `NOM.COMARCA` per presentar variància nul·la. A més, es menyspreen les dades de `GEOREFERENCIA`, doncs aquest es calcularà posteriorment a partir de la `LONGITUD` i la `LATITUD`, a més, es descarta l'`ALTITUD` per no ser necessària per a l'estudi. 

```{r}
drop <- c('AREA.URBANA', 'CODI.INE', 'MUNICIPI', 'CODI.COMARCA', 'NOM.COMARCA', 'ALTITUD', 'GEOREFERENCIA')
dfEstacions <- dfEstacions[,(!names(dfEstacions) %in% drop)]
dfEstacions <- dfEstacions %>% distinct()
cat("Variables rellevants:", vector.print.with.and(names(dfEstacions)))
```

Comentar que s'ha de treballar amb un nivell de precisió geogràfica inferior per unificar la longitud i latitud de les estacions que presenten lleugeres variacions en funció de la mesura enregistrada.

```{r}
dfEstacions$LONGITUD <- round(dfEstacions$LONGITUD, 3)
dfEstacions$LATITUD <- round(dfEstacions$LATITUD, 4)
dfEstacions <- dfEstacions %>% distinct()

dfEstacions$NOM.ESTACIO_curt <- removeWords(as.character(dfEstacions$NOM.ESTACIO), c('Barcelona'))
dfEstacions$NOM.ESTACIO_curt <- gsub('[()]', '', dfEstacions$NOM.ESTACIO_curt)
dfEstacions$NOM.ESTACIO_curt <- as.factor(trim(dfEstacions$NOM.ESTACIO_curt))

taula(dfEstacions)
```

S'estandarditzen els noms de les variables perquè figurin en anglès.

```{r}
dfEstacions <- dfEstacions[,!names(dfEstacions) %in% c('NOM.ESTACIO')]
colnames(dfEstacions) <- c('stationId', 'stationType', 'lat', 'long', 'stationName')
str(dfEstacions)
```

Per altra banda, es seleccionen les variables específiques de les mesures.

```{r}
attr <- c('NOM.ESTACIO', 'TIPUS.ESTACIO', 'AREA.URBANA', 'CODI.INE', 'MUNICIPI',
          'CODI.COMARCA', 'NOM.COMARCA', 'LATITUD', 'LONGITUD', 'ALTITUD', 'GEOREFERENCIA')
dfMesures <- dfQualitatAire[,(!names(dfQualitatAire) %in% attr)]

summary(dfMesures[, 1:5])
```
 
```{r}
paged_table(as.data.frame(t(do.call(cbind, lapply(dfMesures[,6:29], summary)))))
```

El camp `MAGNITUD` conté el codi identificatiu del contaminant, però s'opta per treballar directament amb el nom del contaminant en ser un literal petit, i s'elimina la variable `UNITATS`.

```{r}
dfMesures <- dfMesures[,(!names(dfMesures) %in% c('MAGNITUD','UNITATS'))]
str(dfMesures)
```

Cercant *outliers* a partir dels valors màxims de les estadístiques descriptives anteriors, es pot veure que ressalten certs registres del contaminant $PM_{10}$, els quals presenten valors superiors a $76$, considerat l'inici de l'últim tram de menor ICQA. Realment aquestes dades no són *outliers*, doncs es corresponen a mesures realitzades la matinada del 24/06, coincidint amb la Revetlla de Sant Joan, on els focs artificials generen gran quantitat de partícules en suspensió.

```{r}
paged_table(as.data.frame(t(do.call(cbind, lapply(dfMesures[dfMesures$CONTAMINANT=='PM10',4:27], summary)))))
```

```{r}
paged_table(dfMesures[dfMesures$CONTAMINANT=='PM10' & !is.na(dfMesures$X01h) & dfMesures$X01h == 628,])
```

```{r}
paged_table(dfMesures[(dfMesures$CONTAMINANT=='PM10' & !is.na(dfMesures$X03h) & (dfMesures$X03h > 1000)),])
```

```{r}
paged_table(dfMesures[dfMesures$CONTAMINANT=='PM10' & (dfMesures$DATA %in% c('24/06/2017', '24/06/2018', 
                                                                       '24/06/2019', '24/06/2020')),
                c('CODI.EOI', 'DATA', 'X01h', 'X02h', 'X03h', 'X04h', 'X05h')])
```

Tot seguit es calculen els valors d'immissió diaris de cada contaminant.

```{r}
v24h <- NULL
v8hm <- NULL

#per cada fila de mesures de qualitat de l'aire, calcular el valor d'immissió diari
for (row in 1:nrow(dfMesures)){
  
  #seleccionar els camps del DF que contenen les 24 mesures enregistrades (1 per hora)
  values <- as.data.frame(dfMesures)[row, 4:27]
  
  #pels contaminants NO2, SO2 i O3, el valor d'immissió diari es correspon al màxim valor enregistrat,
  #si durant el dia no s'ha pres cap mesura, el valor d'immissió serà nul,
  #en cas contrari, serà el màxim obviant els NA's
  if(dfMesures[row,]$CONTAMINANT %in% c('NO2', 'SO2', 'O3')){
    if(!all(is.na(values))){
      dfMesures[row, 'valorImmissio'] <- apply(values, 1, max, na.rm=TRUE)
    }
    
  #pel contaminant PM10, el valor es calcula com la mitjana de les 24 mesures
  #si durant el dia no s'ha pres cap mesura, el valor d'immissió serà nul, 
  #en cas contrari, serà la mitjana descomptant els NA's
  }else if(dfMesures[row,]$CONTAMINANT=='PM10'){
    if(!all(is.na(values))){
      dfMesures[row, 'valorImmissio'] <- apply(values, 1, mean, na.rm=TRUE)
    }
    
  #pel contaminant CO es calcula la mitjana de valors de cada rang de 8 hores mòbils i el valor d'immissió
  #diari assignat es correspon al valor màxim calculat
  }else{
    
    for(v in values){
      
      #moure la finestra horària i considerar només els 7 valors anteriors més el nou valor
      if(length(v8hm)>=8){
        v8hm <- v8hm[-1]
      }
      v8hm <- append(v8hm, v)
      
      #calcular la mitjana de valors de les últimes 8h i afegir el valor en el vector dels 24 valors del dia
      v24h <- append(v24h, mean(v8hm, na.rm=TRUE))
    }
    
    #si s'han enregistrat dades durant el dia, el valor de CO diari es correspon al màxim de les mesures
    #acumulades en les 8 últimes hores
    if(!all(is.na(v24h))){
      dfMesures[row, 'valorImmissio'] <- max(v24h, na.rm=TRUE)
    }
    
    v24h <- NULL
  }
}
```

A continuació, s'eliminen les mesures horàries i es treballa amb el valor d'immissió diari calculat.

```{r}
dfMesures[,4:27] <- list(NULL)
str(dfMesures)
```

Es detecten els valors absents i es descarten aquells dies que les estacions no han enregistrat cap valor i que, per tant, no disposen d'un valor d'immissió diari.

```{r}
NAs.num <- sapply(dfMesures, function(k)sum(is.na(k)))
print(NAs.num[NAs.num!=0])
```

```{r}
dfMesures <- dfMesures[!is.na(dfMesures$valorImmissio),]

NAs.num <- sapply(dfMesures, function(k)sum(is.na(k)))
if(length(NAs.num[NAs.num!=0])==0){
  cat('No hi ha valors absents!')
}else{
  cat(NAs.num[NAs.num!=0])
}
```

```{r}
cat('En total es treballa amb', nrow(dfMesures), "registres de mesures enregistrades")
```

Tot seguit, es transforma la variable `DATA` perquè sigui reconeguda com a tipus `Date`, i a partir d'aquesta es calcula l'any, mes i tipus de dia en el qual es va prendre cada mesura.

```{r}
dfMesures$DATA <- as.Date(as.character(dfMesures$DATA), format="%d/%m/%Y")
dfMesures$year <- format(dfMesures$DATA, format = "%Y")
dfMesures$month <- as.numeric(format(dfMesures$DATA, format = "%m"))
dfMesures$day <- weekdays(dfMesures$DATA)

taula(head(dfMesures), full_width=F)
```

Es recalculen els literals de la variable `day` perquè coincideixin amb els del conjunt d'aforament.

```{r}
dfMesures$day <- as.factor(dfMesures$day)

#afegir els nous nivells
levels(dfMesures$day) <- c(levels(dfMesures$day), 'laborable', 'dilluns', 'divendres', 'dissabte', 'diumenge')

#reassignar els valors dels nivells
dfMesures[dfMesures$day %in% c('martes', 'miércoles', 'jueves'),]$day <- 'laborable'
dfMesures[dfMesures$day=='lunes',]$day <- 'dilluns'
dfMesures[dfMesures$day=='viernes',]$day <- 'divendres'
dfMesures[dfMesures$day=='sábado',]$day <- 'dissabte'
dfMesures[dfMesures$day=='domingo',]$day <- 'diumenge'

dfMesures$day <- droplevels(as.factor(dfMesures$day))
cat(levels(dfMesures$day))
```

Per cada estació, contaminant i dia (any i mes), es calcula la mitjana enregistrada, per agregar les dades de forma equivalent a les que es disposa d'aforaments.

```{r}
dfValorIm <- aggregate(list(valorImmissio=dfMesures$valorImmissio), by=list(CODI.EOI=dfMesures$CODI.EOI, 
                                                                            CONTAMINANT=dfMesures$CONTAMINANT, 
                                                                            year=dfMesures$year, 
                                                                            month=dfMesures$month, 
                                                                            day=dfMesures$day), FUN=mean)
taula(head(dfValorIm), full_width=F)
```

A continuació, es creen les rectes de regressió per cada contaminant i rang de valors per obtenir el seu ICQA a partir del valor d'immissió enregistrat.

```{r}
#definir els límits dels rangs de l'ICQA i de cada contaminant
icqa <- c(100,50,49,0,-1,-50,-51, -100)
O3 <- c(0,110,111,180,181,240,241,500) 
PM10 <- c(0,35,36,50,51,75,76,100) 
CO <- c(0,5,6,10,11,15,16,100) 
SO2 <- c(0,200,201,350,351,500,501,1000) 
NO2 <- c(0,90,91,200,201,400,401,1000) 

qa <- data.frame(icqa, O3, PM10, CO, SO2, NO2)

#funció que calcula l'ordenada a l'origen coneixent un punt i el pendent de la recta
ordenada = function(x,y,pendent){
  return (y-(pendent*x))
}

rectes <- data.frame()

#per cada contaminant i categoria d'ICQA, calcular el model de regressió
for (contaminant in names(qa)[-1]){
  for(i in seq(from=1, to=8, by=2)){

    #definir els límits d'ús de cada recta
    xmax <- qa[i+1, contaminant]
    xmin <- qa[i, contaminant]
    
    #crear la recta
    m <- (qa[i+1, 'icqa']-qa[i, 'icqa'])/(xmax-xmin)
    b <- ordenada(qa[i, contaminant], qa[i, 'icqa'], m)
    
    r <- data.frame(contaminant,xmin,xmax,m,b)

    rectes <- bind_rows(rectes, r)
  }
}
taula((rectes), full_width=F)
```

Per cada registre, es cerca el contaminant que s'ha enregistrat i es selecciona la recta de regressió a utilitzar comparant els límits mínims i màxims d'ús de cadascuna d'elles amb el valor d'immissió mesurat.
Aquest procés retorna el valor d'ICQA associat a cada registre.

```{r}
icqa_values <- NULL

#per cada registre d'estació, contaminant i dia (mes i any)
for(row in 1:nrow(dfValorIm)){
  
  #obtenir el contaminant enregistrat i el valor d'immissió associat
  c <- dfValorIm[row,]$CONTAMINANT
  x <- dfValorIm[row,]$valorImmissio
  
  #cercar la recta de regressió en funció del contaminant i rang que li pertoca segons el valor d'immissió
  r <- rectes[rectes$contaminant==as.character(c) & rectes$xmin<=round(x,0) & rectes$xmax>=round(x,0),]
  
  #calcular el valor d'ICQA interpolant el valor d'immissió dins de la recta associada 
  #(ICQA(x)= x*pendent + ordenada)
  icqa_values <- append(icqa_values, x*r$m+r$b)
}

dfValorIm$ICQA <- icqa_values
taula(head(dfValorIm), full_width=F)
```

Si una estació mesura més d'un contaminant, el valor d'ICQA associat a aquella estació en aquell dia, es correspon al valor d'ICQA menor, el que denota, que hi ha més presència d'un agent contaminant, i que per tant, la qualitat de l'aire és inferior.

```{r}
#obtenir per cada estació el valor d'ICQA d'aquell dia
dfValorICQA <- aggregate(list(ICQA=dfValorIm$ICQA), by=list(CODI.EOI=dfValorIm$CODI.EOI, year=dfValorIm$year, 
                                                            month=dfValorIm$month, day=dfValorIm$day), FUN=min)
taula(head(dfValorICQA), full_width=F)
```

Per últim, s'assigna un literal que denota la qualitat de l'aire de cada estació en funció del valor d'ICQA associat.

```{r}
dfValorICQA$airQuality <- ifelse((dfValorICQA$ICQA>=50), "Bona", 
                                 ifelse((dfValorICQA$ICQA>=0 & dfValorICQA$ICQA<50), "Regular", "Pobre"))
dfValorICQA$airQuality <- factor(dfValorICQA$airQuality, levels=c("Bona", "Regular", "Pobre"))

head(paste(round(dfValorICQA$ICQA,0), dfValorICQA$airQuality), 30)
```

A més, es reanomenen les variables perquè totes elles figurin en anglès, estandarditzant així els noms dels diferents estudis.

```{r}
colnames(dfValorICQA) <- c('stationId', 'year', 'month', 'day', 'ICQA', 'airQuality')
str(dfValorICQA)
```

Finalment, s'uneixen les dades de qualitat (`dfValorICQA`) amb la informació relativa a l'estació a la qual fa referència (`dfEstacions`), tot creant l'objecte de tipus *simple feature* (SF) a partir de les coordenades `LONGITUD` i `LATITUD` (en format WGS84), per les quals ha sigut necessari aplicar la transformació al sistema de referència legal.

```{r}
dfMesuresQA <- merge(dfEstacions, dfValorICQA, by='stationId')
sfMesuresQA <- st_as_sf(dfMesuresQA, coords=c('long', 'lat'), crs=st_crs(4326))

#transformar al crs legal
sfMesuresQA <- st_transform(sfMesuresQA, crs=crs_legal)
str(sfMesuresQA)
```

Per altra banda, s'enriqueix el conjunt d'estacions creat inicialment perquè contingui a nivell anual el tipus de qualitat d'aire que ha predominat (mitjana anual d'ICQA).

```{r}
dfEstacioQA <- ddply(sfMesuresQA, .(year, stationId), summarise, icqa=mean(ICQA))
dfEstacioQA$airQuality <- ifelse((dfEstacioQA$icqa>=50), "Bona", 
                                 ifelse((dfEstacioQA$icqa>=0 & dfEstacioQA$icqa<50), "Regular", "Pobre"))

dfEstacioQA$airQuality <- factor(dfEstacioQA$airQuality, levels=c("Bona", "Regular", "Pobre"))
taula(head(dfEstacioQA), full_width=F)
```

```{r}
dfEstacioQA <- merge(dfEstacions, dfEstacioQA, by=c('stationId'))
sfEstacioQAMitj <- st_as_sf(dfEstacioQA, coords=c('long', 'lat'), crs=st_crs(4326))

#transformar al crs legal
sfEstacioQAMitj <- st_transform(sfEstacioQAMitj, crs=crs_legal)
str(sfEstacioQAMitj)
```



## 4.3. Anàlisi de dades

Tot seguit, s'analitza numèricament l'evolució de la qualitat de l'aire.

En primer lloc, es calcula el nombre de mesures que s'han pres de cada tipus de qualitat d'aire al llarg dels anys. Es pot observar que hi ha un creixement de gairebé el 30% entre els 2017 i 2019 d'ICQA etiquetats com de bona qualitat (s'entén l'excepcionalitat de l'any 2020 per la COVID, on evidentment la qualitat millora més del 50% respecte al 2017 degut a la reducció de tràfic). A més, hi ha una reducció d'aproximadament un 25% d'enregistraments de qualitat d'aire regular al 2019 respecte al 2017. Tot i que en comparació amb la qualitat d'aire del 2018, s'observa un comportament invers, doncs del 2018 al 2019 s'aprecia un lleuger empitjorament.

```{r}
COLORS <- c("Bona"="#00BA38", "Regular"="#DDAA2D", "Pobre"="#F8766D")

dfStats <- ddply(sfMesuresQA, .(year, airQuality), summarise, num=length(stationId))

ggplot(dfStats, aes(x=as.numeric(year), y=num)) + 
  geom_line(aes(color=airQuality), size = 1) +
  ggtitle("Evolution of Air Quality measures") + 
  xlab("Temporality") + ylab("Number of measures taken") + ylim(0, max(dfStats$num)+50) + 
  scale_colour_manual(values = COLORS)
```

```{r}
calcDifferenceByYear(dfStats, "airQuality", "2019")
```

```{r}
calcDifferenceByYear(dfStats[dfStats$airQuality!='Pobre',], "airQuality", "2020")
```

Separant les mesures per tipus d'estació, és a dir, el tipus d'ambient que mesura, es pot dir que les de `background` tenen el mateix comportament que el conjunt, doncs predomina aquest tipus d'estació, mentre que el tràfic sempre tendeix a millorar.

```{r fig.width = 10, fig.height = 3}
dfStats <- ddply(sfMesuresQA, .(year, airQuality, stationType), summarise, num=length(stationId))

ggplot(dfStats, aes(x=as.numeric(year), y=num)) + 
  geom_line(aes(color=airQuality), size = 1) +
  facet_wrap(. ~stationType, scales="free") + 
  ggtitle("Evolution of Air Quality measures") + 
  xlab("Temporality") + ylab("Number of measures taken") + ylim(0, max(dfStats$num)+10) + 
  scale_colour_manual(values = COLORS)
```

```{r}
calcDifferenceByYear(dfStats[dfStats$stationType=='background',], "airQuality", "2019")
```

```{r}
calcDifferenceByYear(dfStats[dfStats$stationType=='traffic',], "airQuality", "2019")
```

Desglossant les mesures per tipus de dia de la setmana, es pot veure que el pitjor dia a nivell de qualitat de l'aire és el divendres, doncs s'aprecia un augment de mesures catalogades com Regulars així com l'aparició d'enregistraments Pobres, en detriment de les Bones.

```{r fig.width = 16, fig.height = 5}
dfStats <- ddply(sfMesuresQA, .(year, day, airQuality), summarise, num=length(stationId))
dfStats$day <- factor(dfStats$day, levels = c("dilluns", "laborable", "divendres", "dissabte", "diumenge"))

ggplot(dfStats, aes(x=day, y=num, fill=airQuality)) + 
  geom_bar(stat='identity', position=position_dodge(width = 0.9, preserve = "single")) + 
  facet_grid(.~year, scales="free") + 
  ggtitle("Evolution of Air Quality") + xlab("Temporality") + ylab("Number measures") + 
  scale_y_continuous(labels=comma_format(big.mark=".", decimal.mark=",")) + scale_fill_manual(values=COLORS) +
  theme(axis.text=element_text(size=8))
```

Aquest mateix fet es mostra en la següent gràfica, la qual permet veure el mateix patró que la comparativa d'ús de la infraestructura realitzat en el punt 2.3 però invertit.
És a dir, a diferència de l'aforament, les gràfiques de qualitat mostren una tendència a l'alça els caps de setmana, denotant una millora en la qualitat de l'aire per la reducció de trànsit.

```{r fig.width = 16, fig.height = 5}
dfStats <- ddply(sfMesuresQA, .(year, airQuality, day), summarise, icqa=ICQA)
dfStats$day <- factor(dfStats$day, levels = c("dilluns", "laborable", "divendres", "dissabte", "diumenge"))

ggplot(dfStats, aes(y=icqa, x=day, color=airQuality)) + 
  geom_boxplot(color='black', outlier.shape = NA) + 
  geom_jitter(position=position_jitter(0.2))+
  facet_grid(.~year, scales="free") + 
  ggtitle("Air Quality per type of day") + xlab("Temporality") + ylab("ICQA") + 
  scale_y_continuous(labels=comma_format(big.mark=".", decimal.mark=",")) + scale_color_manual(values=COLORS)
```

Visualitzant l'evolució de les mesures de qualitat d'aire preses, tenint en compte el mes com a unitat temporal, no es pot establir un clar patró de comportament. Com a molt es pot entreveure que els mesos que acostumen a presentar una qualitat d'aire inferior són el març i el juny.

```{r fig.width = 20, fig.height = 5}
dfStatsQualitat <- ddply(sfMesuresQA, .(month, airQuality, year), summarise, num=length(stationId))
dfStatsQualitat$Temporality <- as.yearmon(paste0(dfStatsQualitat$year, '-', dfStatsQualitat$month))

ggplot(dfStatsQualitat, aes(x=as.Date(Temporality), y=num)) + 
  geom_area(aes(fill=airQuality),position="identity") +
  scale_fill_manual(values = alpha(COLORS, .25)) +
  ggtitle("Evolution of Air Quality")+ xlab("Temporality") + ylab("Number of measures") +  
  scale_x_date(date_breaks = '2 months', date_labels = '%b-%Y')
```

Finalment, s'intenta establir la correlació entre el tràfic motoritzat i la qualitat de l'aire. Per això, es creen dos subconjunts avaluant en el cas de l'aire el nombre d'enregistraments que s'han realitzat de qualitat Regular, que denotaria que hi ha partícules nocives en l'ambient, i en el cas dels aforaments es pren com a referència la mitjana d'IMD de tràfic, tot tenint en compte la temporalitat a nivell de mes.

A més, per comparar en una mateixa gràfica els dos conceptes, es combinen les estadístiques individuals tot normalitzant el valor numèric de qualitat regular i d'aforaments de tràfic.

```{r}
#calcular el nombre d'estacions que enregistren valors de qualitat regular
dfStatsQualitatBona <- ddply(sfMesuresQA[sfMesuresQA$airQuality=='Regular',], .(month, year), 
                             summarise, num=length(stationId))
dfStatsQualitatBona$Temporality <- as.yearmon(paste0(dfStatsQualitatBona$year, '-', dfStatsQualitatBona$month))

#calcular la mitjana de trànsit
dfStatsAfoTransit <- ddply(sfMesuresAfor[sfMesuresAfor$equipmentType=='trànsit',], .(month, year), 
                           summarise, num=mean(IMDvalue))
dfStatsAfoTransit$Temporality <- as.yearmon(paste0(dfStatsAfoTransit$year, '-', dfStatsAfoTransit$month))

#normalitzar els dos conjunts per separat
dfStatsAfoTransit$data <- 'Aforaments trànsit'
dfStatsAfoTransit$num <- rescale(dfStatsAfoTransit$num)

dfStatsQualitatBona$data <- 'Qualitat regular aire'
dfStatsQualitatBona$num <- rescale(dfStatsQualitatBona$num)

#unir les estadístiques
comp <- rbind(dfStatsAfoTransit, dfStatsQualitatBona)
```

En la següent gràfica no es pot establir una correlació directa entre els dos fets, doncs la qualitat de l'aire no depèn únicament del trànsit, sinó de múltiples fenòmens, entre els quals es troba el meteorològic com la pluja, que redueix la intensitat d'agents nocius en l'aire, millorant la qualitat d'aquesta.

```{r fig.width = 20, fig.height = 5}
ggplot(comp, aes(x=Temporality,y=num,group=data)) +
    geom_area(aes(fill=data),position="identity") +
    scale_fill_manual(values = alpha(c("#F8766D","#DDAA2D"), .25)) +
    labs(title="Comparative between Aire Quality and Infraestructure use (Traffic) ",
        y="(normalized)", x="Temporality")
```

Calculant la mètrica de correlació, aquest cop tenint en compte el valor mitjà d'ICQA enregistrat i d'IMD per dia, mes i any, es pot veure que estan inversament relacionats, però amb un grau baix de correlació ($-0.53$). 

```{r}
#calcular mitjana ICQA
dfQualitatBona <- ddply(sfMesuresQA, .(month, year, day), summarise, icqa=mean(ICQA))
dfQualitatBona$Temporality <- as.yearmon(paste0(dfQualitatBona$year, '-', dfQualitatBona$month))
dfQualitatBona <- dfQualitatBona[,c('year', 'month', 'day', 'icqa', 'Temporality')]

#calcular la mijtana trànsit
dfAforament <- ddply(sfMesuresAfor[sfMesuresAfor$equipmentType=='trànsit',], .(month, year, day), summarise, imd=mean(IMDvalue))
dfAforament$Temporality <- as.yearmon(paste0(dfAforament$year, '-', dfAforament$month))
dfAforament <- dfAforament[,c('year', 'month', 'day', 'imd', 'Temporality')]

#unir els conjunts per moment temporal
cor <- merge(dfAforament, dfQualitatBona, by=c('year', 'month', 'day', 'Temporality'))

#calcular la correlació
ggpairs(cor[,c('imd', 'icqa')], progress=FALSE)
```

En aquest punt es generen les capes a ArcGIS Pro per realitzar l'estudi geoespacial.

```{r}
arc.delete(paste0(ARCGIS_PRO_PATH, 'qualitatAire'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'qualitatAire'), data=sfMesuresQA, validate=TRUE, overwrite=TRUE)
```

```{r}
arc.delete(paste0(ARCGIS_PRO_PATH, 'estacionsXVPCA'))
arc.write(path=paste0(ARCGIS_PRO_PATH, 'estacionsXVPCA'), data=sfEstacioQAMitj, 
          validate=TRUE, overwrite=TRUE)
```

Per altra banda, es comprova el motiu pel qual les estacions presenten una qualitat d'aire regular, així com el detall de l'estació de l'Observatori Fabra, apareguda al 2018, i que mostra nivells inferiors de qualitat en comparació amb les que es troben més properes al centre urbà.
```{r fig.width = 16, fig.height = 5}
COLORS <- c('NO2'='#FCA638', 'O3'='#38BEFC', 'PM10'='#FC3882', 'CO'='#E7DB4A', 'SO2'='#6B0104')
XVPCA <- dfValorIm[dfValorIm$CODI.EOI %in% c(8019043, 8019004, 8019058),]

#calcular la mitjana anual del valor d'immissió de cada contaminant per estació
dfStats <- aggregate(XVPCA$valorImmissio, by=list(stationId=XVPCA$CODI.EOI, pollutant=XVPCA$CONTAMINANT, 
                                                  year=XVPCA$year, month=XVPCA$month), FUN=mean)

dfStats <- merge(dfStats, dfEstacions, by=c('stationId'))
dfStats$stationName <- factor(dfStats$stationName, levels=c("Eixample", "Poblenou", "Observatori Fabra"))
dfStats$Temporality <- as.yearmon(paste0(dfStats$year, '-', dfStats$month))

ggplot(dfStats, aes(x=as.Date(Temporality), y=x)) + 
  geom_line(aes(color=pollutant), size = 1.5) +
  facet_wrap(. ~stationName)+
  scale_colour_manual('Pollutant', values = COLORS) + 
  ggtitle("Evolution of contamination")+ xlab("Temporality") + ylab("Mean immision value") +
  theme(text = element_text(size = 12), strip.text = element_text(size=12))
```

En la següent gràfica es pot apreciar com cada nivell de contaminant afecta l'ICQA en diferent mesura, essent en el cas de l'estació de l'Eixample l'NO2 i le PM10 els contaminants que més afecten negativament a l'ICQA de la zona, i l'O3 a la zona on es troba l'Observatori Fabra.

```{r fig.width = 16, fig.height = 5}
#calcular la mitjana anual del valor d'immissió de cada contaminant per estació
dfStats <- aggregate(XVPCA$ICQA, by=list(stationId=XVPCA$CODI.EOI, pollutant=XVPCA$CONTAMINANT, year=XVPCA$year, month=XVPCA$month), FUN=mean)
dfStats <- merge(dfStats, dfEstacions, by=c('stationId'))
dfStats$stationName <- factor(dfStats$stationName, levels=c("Eixample", "Poblenou", 
                                                            "Observatori Fabra"))
dfStats$Temporality <- as.yearmon(paste0(dfStats$year, '-', dfStats$month))

ggplot(dfStats, aes(x=as.Date(Temporality), y=x)) + 
  #afegir de fons els  tres colors del semàfor de qualitat
  ggplot2::annotate('rect', fill = '#F8766D', alpha = 0.25, 
                    xmin=as.Date(as.yearmon(paste0(2017,'-',01))), xmax=as.Date(as.yearmon(paste0(2021,'-',01))),
                    ymin=-10, ymax = -0.1) +
  ggplot2::annotate('rect', fill = '#DDAA2D', alpha = 0.25, 
                    xmin=as.Date(as.yearmon(paste0(2017,'-',01))), xmax=as.Date(as.yearmon(paste0(2021,'-',01))),
                    ymin= 0, ymax = 49.9) +
  ggplot2::annotate('rect', fill = '#00BA38', alpha = 0.25, 
                    xmin=as.Date(as.yearmon(paste0(2017,'-',01))), xmax=as.Date(as.yearmon(paste0(2021,'-',01))),
                    ymin=50, ymax = 100) +
  
  geom_line(aes(color=pollutant), size = 1.5) +
  facet_wrap(. ~stationName) +
  scale_colour_manual('Contaminant', values = COLORS) + xlab("") + ylab("ICQA") + ylim(-10,100) +
  theme(text = element_text(size = 12), strip.text = element_text(size=12))
```



# 5. ArcGIS Online

Per tal d'enriquir el visor d'AGOL es creen un seguit de conjunts de dades i gràfiques específiques per cada temàtica.


## 5.1. Infraestructura ciclable

Es transforma el format de les estadístiques calculades en l'apartat 1.3. per poder-les incorporar com a font de dades addicional al WAB i construir el gràfic amb l'evolució de la infraestructura.

```{r}
statsWAB <- as.data.frame(dfStatsKmType$temporality)
statsWAB <- statsWAB %>% distinct()
colnames(statsWAB) <- c('temporality')

x <- c('carrers pacificats', 'carril bici', 'carril bici cons', 
       'corredors bici', 'ronda verda', 'vies ciclables')

for(v in x){
  statsWAB[,v] <- NA
}

#es pivota el conjunt d'estadístiques de quilometratge de cada tipus de via per moment temporal
for (i in 1:nrow(dfStatsKmType)){
  statsWAB[statsWAB$temporality==dfStatsKmType[i,]$temporality, 
           colnames(statsWAB) %in% dfStatsKmType[i,]$type] <- round(dfStatsKmType[i,]$n,2)
}

t <- NULL
for (i in 1:nrow(statsWAB)){
  instant <- paste0(format(statsWAB[i,]$temporality, '%m'),format(statsWAB[i,]$temporality, '%d'))
  t <- append(t, paste0(format(statsWAB[i,]$temporality, '%Y'), ' ', TEMPORALITY_QUARTER[[instant]]))
}
statsWAB$time <- t

taula(statsWAB, full_width=F)
```

```{r}
write.csv(statsWAB, paste0(AGOL_PATH, '/T1.', 'estadistInfraestr.csv'), row.names = FALSE)
```



## 5.2. Ús de bicicleta

Es carreguen les dades d'aforament dels districtes i barris calculades a ArcGIS Pro. Es transformen els conjunts per obtenir, per cada polígon administratiu, en una mateixa fila l'IMDv i l'IMDb associat, tot normalitzant  els valors de cada variable per poder-los comparar i graficar a l'*Operational Dashboard* d'AGOL.

```{r}
#carregar les dades tractades a ArcGIS Pro
dmTransit <- load_data(paste0(ARCGIS_PRO_PATH_EXPORT, 'T2.aforaments'), 'districtes_mesures_transit', 'zip', rename=FALSE)
dmBici <- load_data(paste0(ARCGIS_PRO_PATH_EXPORT, 'T2.aforaments'), 'districtes_mesures_bicis', 'zip', rename=FALSE)

df_dmTransit <- as.data.frame(dmTransit)
df_dmBici <- as.data.frame(dmBici)

#unir els conjunts de dades de trànsit i bici per districte i any
dm <- merge(df_dmTransit, df_dmBici, by=c('DISTRICTE', 'NOM', 'year'), all=TRUE)
dm <- dm[,colnames(dm) %in% c('DISTRICTE', 'year', 'NOM', 'IMDv', 'IMDb')]

#normalitzar l'IMDv i IMDb
dm$IMDv <- rescale(dm$IMDv)
dm$IMDb <- rescale(dm$IMDb)
dm[is.na(dm$IMDb),]$IMDb <- 0
taula(head(dm), full_width=F)
```

```{r}
write.csv(dm, paste0(AGOL_PATH, '/T2.', 'estadistUsDistrictes.csv'), row.names = FALSE)
```

Es repeteix el mateix procediment pels barris.

```{r}
#carregar les dades tractades a ArcGIS Pro
bmTransit <- load_data(paste0(ARCGIS_PRO_PATH_EXPORT, 'T2.aforaments'), 'barris_mesures_transit', 'zip', rename=FALSE)
bmBici <- load_data(paste0(ARCGIS_PRO_PATH_EXPORT, 'T2.aforaments'), 'barris_mesures_bicis', 'zip', rename=FALSE)

df_bmTransit <- as.data.frame(bmTransit)
df_bmBici <- as.data.frame(bmBici)

#unir els conjunts de dades de trànsit i bici per barri i any
bm <- merge(df_bmTransit, df_bmBici, by=c('BARRI', 'NOM', 'year'), all=TRUE)
bm <- bm[,colnames(bm) %in% c('BARRI', 'year', 'NOM', 'IMDv', 'IMDb')]

#normalitzar l'IMDv i IMDb
bm$IMDv <- rescale(bm$IMDv)
bm$IMDb <- rescale(bm$IMDb)
bm[is.na(bm$IMDb),]$IMDb <- 0
bm[is.na(bm$IMDv),]$IMDv <- 0
taula(head(bm), full_width=F)
```

```{r}
write.csv(bm, paste0(AGOL_PATH, '/T2.', 'estadistUsBarris.csv'), row.names = FALSE)
```

Per altra banda, es calculen les estadístiques mensuals d'aforament de trànsit i bicis per generar a AGOL el gràfic evolutiu.

```{r}
df_m <- as.data.frame(sfMesuresAfor)
df_m <- df_m[df_m$equipmentType!='rondes',]

#calcular la mitjana mensual d'IMD de trànsit i bicis
df_mTransit <- ddply(df_m[df_m$equipmentType=='trànsit',], .(year, month), summarise, IMDv=mean(IMDvalue))
df_mBicis <- ddply(df_m[df_m$equipmentType=='bicis',], .(year, month), summarise, IMDb=mean(IMDvalue))

#normalitzar els IMD
df_mTransit$IMDv <- rescale(df_mTransit$IMDv)
df_mBicis$IMDb <- rescale(df_mBicis$IMDb)

df_mMensual <- merge(df_mTransit, df_mBicis, by=c('year', 'month'))
df_mMensual$Temporality <- as.yearmon(paste0(df_mMensual$year, '-', df_mMensual$month))
taula(head(df_mMensual), full_width=F)
```

```{r}
write.csv(df_mMensual, paste0(AGOL_PATH, '/T2.', 'estadistUsMensuals.csv'), row.names = FALSE)
```

Finalment, es generen els GIF comparatius d'IMDv i IMDb, calculant la mitjana d'IMD de cada tipus d'equip per límit administratiu (districte o barri) i any.

```{r}
#calcular la mitjana d'IMDv i IMDb per districte i any
dfStats <- ddply(sfEquipsMitjAfor, .(year, districtId, equipmentType), summarise, IMD=mean(IMDmean))

#normalitzar els valors d'IMD
dfStatsBicis <- dfStats[dfStats$equipmentType=='bicis',]
dfStatsBicis$IMDb <- rescale(dfStatsBicis$IMD)
dfStatsTransit <- dfStats[dfStats$equipmentType=='trànsit',]
dfStatsTransit$IMDv <- rescale(dfStatsTransit$IMD)

#obtenir la relació identificador districte - nom districte
d <- as.data.frame(districtes)[,c('DISTRICTE', 'NOM')]
d$DISTRICTE <- as.numeric(d$DISTRICTE)
d$DISTRICTE <- as.factor(d$DISTRICTE)
names(d) <- c('districtId', 'districtName')

#generar un únic conjunt amb l'IMDv i IMDb
comp <- merge(dfStatsBicis, dfStatsTransit, by=c('year', 'districtId'))
comp <- comp[,c('year', 'districtId', 'IMDb', 'IMDv')]

#convertir en negatiu l'IMDv per realitzar un gràfic de barres mirall
comp <- mutate(comp, IMDv = -IMDv)

#enriquir el conjunt amb el nom del districte
comp <- merge(comp, d, by='districtId')

taula(head(comp), full_width=F)
```

```{r message=FALSE, warning = FALSE}
#importar la llibreria per aplicar una temàtica fosca als gràfics
library(ggdark)

g <- ggplot(comp, aes(y = districtName)) +
  geom_col(aes(x = IMDb), fill = "#00BA38") +
  geom_col(aes(x = IMDv), fill = "#F8766D")  +
  scale_y_discrete(limits=rev(levels(comp$districtName)))+
  labs(title = '{trunc(frame_time,0)} - {trunc((frame_time+1),0)}', x = 'IMD', y = '') +
  transition_time(year) + ease_aes('linear') +
  theme(axis.text.x=element_blank()) + dark_theme_gray() + 
  theme(text = element_text(size = 16), strip.text = element_text(size=17))

animate(g, end_pause = 15, renderer=gifski_renderer(paste0(AGOL_PATH, '/T2.', "usDistrictes.gif")))
```

Es repeteix el procediment realitzant la gràfica a nivell de barris.

```{r}
#calcular la mitjana d'IMDv i IMDb per barri i any
dfStats <- ddply(sfEquipsMitjAfor, .(year, neighborhoodId, equipmentType), summarise, IMD=mean(IMDmean))

#normalitzar els valors d'IMD
dfStatsBicis <- dfStats[dfStats$equipmentType=='bicis',]
dfStatsBicis$IMDb <- rescale(dfStatsBicis$IMD)
dfStatsTransit <- dfStats[dfStats$equipmentType=='trànsit',]
dfStatsTransit$IMDv <- rescale(dfStatsTransit$IMD)

#obtenir la relació identificador barri - nom barri
b <- as.data.frame(barris)[,c('BARRI', 'NOM')]
b$BARRI <- as.numeric(b$BARRI)
b$BARRI <- as.factor(b$BARRI)
names(b) <- c('neighborhoodId', 'neighborhoodName')

#generar un únic conjunt amb l'IMDv i IMDb
comp <- merge(dfStatsBicis, dfStatsTransit, by=c('year', 'neighborhoodId'))
comp <- comp[,c('year', 'neighborhoodId', 'IMDb', 'IMDv')]

#convertir en negatiu l'IMDv per realitzar un gràfic de barres mirall
comp <- mutate(comp, IMDv = -IMDv)

#enriquir el conjunt amb el nom del barri
comp <- merge(comp, b, by='neighborhoodId')

taula(head(comp), full_width=F)
```

```{r}
#limitar el nom del barri a 20 caràcters, afegint punts suspensius al final
comp$name <- ifelse((nchar(comp$neighborhoodName)>20), (paste0(substr(comp$neighborhoodName,1,17), '...')),  comp$neighborhoodName)

g <- ggplot(comp, aes(y = name)) +
  geom_col(aes(x = IMDb), fill = "#00BA38") +
  geom_col(aes(x = IMDv), fill = "#F8766D")  +
  scale_y_discrete(limits=rev(levels(comp$name)))+
  labs(title = '{trunc(frame_time,0)} - {trunc((frame_time+1),0)}', x = 'IMD', y = '') +
  transition_time(year) + ease_aes('linear') +
  theme(axis.text.x=element_blank()) + dark_theme_gray() + theme(text = element_text(size = 20))

animate(g, height=800, width=600, end_pause = 15, 
        renderer=gifski_renderer(paste0(AGOL_PATH, '/T2.', "usBarris.gif")))
```



## 5.3. Accidentalitat ciclista

S'apliquen certes transformacions sobre el conjunt d'accidentats per poder generar les gràfiques ordenant els nivells de les variables qualitatives en el *widget* d'infografia de WAB. En concret, es creen rangs horaris, i es reordenen els dies de la setmana. Finalment, es defineix un camp de tipus `Date` per indicar el mes-any de l'accident.

```{r}
sfAccidentats$hourRange <- ifelse((sfAccidentats$hour>=1 & sfAccidentats$hour<=3), "h1. [1-3]", 
                            ifelse((sfAccidentats$hour>=4 & sfAccidentats$hour<=6), "h2. [4-6]", 
                             ifelse((sfAccidentats$hour>=7 & sfAccidentats$hour<=9), "h3. [7-9]",  
                              ifelse((sfAccidentats$hour>=10 & sfAccidentats$hour<=12), "h4. [10-12]",
                               ifelse((sfAccidentats$hour>=13 & sfAccidentats$hour<=15), "h5. [13-15]",
                                ifelse((sfAccidentats$hour>=16 & sfAccidentats$hour<=18), "h6. [16-18]",
                                 ifelse((sfAccidentats$hour>=19 & sfAccidentats$hour<=21), "h7. [19-21]", 
                                         "h8. [22-24]")))))))

sfAccidentats$hourRange <- factor(sfAccidentats$hourRange, levels=c("h1. [1-3]", "h2. [4-6]", "h3. [7-9]", 
                                                                    "h4. [10-12]", "h5. [13-15]", "h6. [16-18]",
                                                                    "h7. [19-21]", "h8. [22-24]"))

head(paste(sfAccidentats$hour, sfAccidentats$hourRange), 30)
```

```{r}
sfAccidentats$dayOrdered <- ifelse((sfAccidentats$day=='Dilluns'), "1.dilluns", 
                             ifelse((sfAccidentats$day=='Dimarts'), "2.dimarts", 
                              ifelse((sfAccidentats$day=='Dimecres'), "3.dimecres", 
                               ifelse((sfAccidentats$day=='Dijous'), "4.dijous", 
                                ifelse((sfAccidentats$day=='Divendres'), "5.divendes", 
                                 ifelse((sfAccidentats$day=='Dissabte'), "6.dissabte", "7.diumenge"))))))
                                          
sfAccidentats$dayOrdered <- factor(sfAccidentats$dayOrdered, levels=c("1.dilluns", "2.dimarts", "3.dimecres",
                                                                      "4.dijous", "5.divendes", "6.dissabte", 
                                                                      "7.diumenge"))

head(paste(sfAccidentats$day, sfAccidentats$dayOrdered), 30)
```

```{r}
sfAccidentats$date <- as.Date(as.yearmon(paste0(sfAccidentats$year, '-', sfAccidentats$month)))
```

Aquest conjunt d'accidentats s'exporta en format *shapefile* per incorporar-lo directament a AGOL.

```{r message=FALSE, warning = FALSE}
st_write(sfAccidentats, dsn = paste0(AGOL_PATH, '/T3.', "accidentats.shp"), driver = "ESRI Shapefile")
```



## 5.4 Qualitat de l'aire

Per últim, es generen els GIF evolutius amb els valors d'ICQA de cada contaminant per estació XVPCA.

```{r fig.width = 16, fig.height = 5}
COLORS <- c('NO2'='#FCA638', 'O3'='#38BEFC', 'PM10'='#FC3882', 'CO'='#E7DB4A', 'SO2'='#6B0104')

#generar un GIF per cada estació
for (e in unique(dfEstacions$stationId)){
  #obtenir tots els valors d'immissió de l'estació
  XVPCA_e <- dfValorIm[dfValorIm$CODI.EOI==e,]
  #calcular per contaminant i moment (any i mes) la mitjana d'immissió
  dfStats <- aggregate(XVPCA_e$ICQA, by=list(stationId=XVPCA_e$CODI.EOI, pollutant=XVPCA_e$CONTAMINANT,
                                             year=XVPCA_e$year, month=XVPCA_e$month), FUN=mean)
  dfStats <- merge(dfStats, dfEstacions, by=c('stationId'))
  dfStats$Temporality <- as.yearmon(paste0(dfStats$year, '-', dfStats$month))
  
  g <- ggplot(dfStats, aes(x=as.Date(Temporality), y=x)) + 
        #afegir de fons els  tres colors del semàfor de qualitat
        ggplot2::annotate('rect', fill = '#F8766D', alpha = 0.25, 
                 xmin = as.Date(as.yearmon(paste0(2017,'-',01))), xmax =as.Date(as.yearmon(paste0(2021,'-',01))),
                 ymin = -10, ymax = -0.9) +
        ggplot2::annotate('rect', fill = '#DDAA2D', alpha = 0.25, 
                 xmin = as.Date(as.yearmon(paste0(2017,'-',01))), xmax =as.Date(as.yearmon(paste0(2021,'-',01))),
                 ymin = 0, ymax = 49.9) +
        ggplot2::annotate('rect', fill = '#00BA38', alpha = 0.25, 
                 xmin = as.Date(as.yearmon(paste0(2017,'-',01))), xmax =as.Date(as.yearmon(paste0(2021,'-',01))),
                 ymin = 50, ymax = 100 )+

        geom_line(aes(color=pollutant), size = 1) +
        facet_wrap(. ~stationName)+
        scale_colour_manual('Contaminant', values = COLORS) +
        #definir la graduació amb la qual aniran apareixent les dades
        transition_reveal(as.Date(Temporality))+
        xlab("") + ylab("ICQA") + ylim(-10,100)+ dark_theme_gray() + 
        theme(text = element_text(size = 15), strip.text = element_text(size=17))

  #animar el gràfic anterior i guardar el fitxer en local
  animate(g, end_pause = 15, width = 600, height = 300, 
          renderer=gifski_renderer(paste0(AGOL_PATH, '/T4.', 'estacioQA_', e,'.gif')))
}
```





